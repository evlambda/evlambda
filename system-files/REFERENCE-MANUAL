<!doctype html>
<!-- SPDX-FileCopyrightText: Copyright (c) 2024-2025 RaphaÃ«l Van Dyck -->
<!-- SPDX-License-Identifier: BSD-3-Clause -->
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="___cssURL___"/>
    <script src="___jsURL___"></script>
    <script>const windowId = ___windowId___;</script>
  </head>
  <body>
    <div class="preamble">
      $\newcommand{\unicode}[1]{U{+}\code{#1}}$
      $\DeclareMathOperator{\lex}{lex}$
      $\DeclareMathOperator{\pat}{pat}$
    </div>
    <h1>Reference Manual</h1>
    <p>The reference manual provides a detailed account of the programming language. It supplements the user manual (particularly the sections &ldquo;Programming Language&rdquo; and &ldquo;Listener Buffers&rdquo;) and the tutorial.</p>
    <h2>Syntax</h2>
    <h3>Introduction</h3>
    <h4>Listener Buffers</h4>
    <p>Let's examine what happens when the form <code>(+ 123 456)</code> is evaluated in a listener buffer:</p>
    <pre class="repl">&gt; (+ 123 456)<br>579</pre>
    <p>The process can be broken down into the following five steps:</p>
    <p><b>Step 1</b> The sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> is read from the listener buffer.</p>
    <p><b>Step 2</b> The reader converts the sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> into the list <code>(+ 123 456)</code>. (The sequence of characters is a readable representation of the list.) This step can be broken down into the following two substeps:</p>
    <p><b>Step 2.1</b> A component of the reader called the tokenizer converts the sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> into a sequence of tokens. A token consists of the following pieces of information bundled together: a category and, if required by the category, a value. Each token category has an associated pattern and each token has an associated lexeme. A lexeme is a sequence of contiguous characters extracted from the input sequence of characters. The lexeme associated with a token must match the pattern associated with the token's category and the sequence of characters resulting from the concatenation of the lexemes associated with the tokens must match the input sequence of characters. The sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> is converted into the following sequence of tokens:</p>
    <ul>
      <li>A token of category <code>opening-parenthesis</code> whose associated lexeme is <span class="charseq"><span class="char">(</span></span>. This token has no value.</li>
      <li>A token of category <code>variable</code> whose associated lexeme is <span class="charseq"><span class="char">+</span></span>. The value of this token is the object of type <code>variable</code> whose name is <span class="charseq"><span class="char">+</span></span>.</li>
      <li>A token of category <code>whitespace</code> whose associated lexeme is <span class="charseq"><span class="char">&nbsp;</span></span>. This token has no value.</li>
      <li>A token of category <code>number</code> whose associated lexeme is <span class="charseq"><span class="char">1</span><span class="char">2</span><span class="char">3</span></span>. The value of this token is an object of type <code>number</code> representing the mathematical number $123$.</li>
      <li>A token of category <code>whitespace</code> whose associated lexeme is <span class="charseq"><span class="char">&nbsp;</span></span>. This token has no value.</li>
      <li>A token of category <code>number</code> whose associated lexeme is <span class="charseq"><span class="char">4</span><span class="char">5</span><span class="char">6</span></span>. The value of this token is an object of type <code>number</code> representing the mathematical number $456$.</li>
      <li>A token of category <code>closing-parenthesis</code> whose associated lexeme is <span class="charseq"><span class="char">)</span></span>. This token has no value.</li>
    </ul>
    <p>Note that some whitespace is needed to separate the lexeme <span class="charseq"><span class="char">+</span></span> from the lexeme <span class="charseq"><span class="char">1</span><span class="char">2</span><span class="char">3</span></span> and the lexeme <span class="charseq"><span class="char">1</span><span class="char">2</span><span class="char">3</span></span> from the lexeme <span class="charseq"><span class="char">4</span><span class="char">5</span><span class="char">6</span></span> but no whitespace is needed to separate the lexeme <span class="charseq"><span class="char">(</span></span> from the lexeme <span class="charseq"><span class="char">+</span></span> or the lexeme <span class="charseq"><span class="char">4</span><span class="char">5</span><span class="char">6</span></span> from the lexeme <span class="charseq"><span class="char">)</span></span>.</p>
    <p><b>Step 2.2</b> A component of the reader called the parser converts the sequence of tokens from step 2.1 (minus the tokens of category <code>whitespace</code>, which are ignored by the parser) into a cons whose car is the variable from step 2.1 and whose cdr is a cons whose car is the first number from step 2.1 and whose cdr is a cons whose car is the second number from step 2.1 and whose cdr is the empty list. Together, those three conses represent the list <code>(+ 123 456)</code>.</p>
    <p><b>Step 3</b> The evaluator evaluates the list <code>(+ 123 456)</code> to the number <code>579</code>. The evaluation of the top-level form <code>(+ 123 456)</code> entails the evaluation of other non-top-level forms. Each form must be classified in order to determine how it should be evaluated. The form <code>(+ 123 456)</code> is classified as a plain function call. The variable <code>+</code> is treated as an abbreviation for the form <code>(fref +)</code>. The form <code>(fref +)</code> is classified as an <code>fref</code>-form. The forms <code>123</code> and <code>456</code> are classified as self-evaluating objects. Because the global function <code>+</code> is a closure, its invocation entails the evaluation (and thus the classification) of other forms. The component of the evaluator responsible for classifying forms is called the syntax analyzer.</p>
    <p><b>Step 4</b> The printer converts the number <code>579</code> into the sequence of characters <span class="charseq"><span class="char">5</span><span class="char">7</span><span class="char">9</span></span>. (The sequence of characters is the printable representation of the number.)</p>
    <p><b>Step 5</b> The sequence of characters <span class="charseq"><span class="char">5</span><span class="char">7</span><span class="char">9</span></span> is written into the listener buffer.</p>
    <p>EVLambda has three levels of syntax:</p>
    <ul>
      <li>The token level contains the rules used by the tokenizer to convert a sequence of characters into a sequence of tokens.</li>
      <li>The object level contains the rules used by the parser to convert a sequence of tokens into a sequence of objects.</li>
      <li>The form level contains the rules used by the syntax analyzer to classify forms.</li>
    </ul>
    <p>Each level of syntax is described later in its own section.</p>
    <h4>EVLambda Source Files</h4>
    <p>The reader is used not only to convert the characters typed into a listener buffer into an object but also to convert the characters contained inside an EVLambda source file into a sequence of objects.</p>
    <p>EVLambda source files come in two varieties: the plain EVLambda source files, which contain only EVLambda source code, and the documented EVLambda source files, which contain a mix of EVLambda source code and documentation in XML format.</p>
    <p>Here is an example of a plain EVLambda source file:</p>
    <pre class="repl">(fdef fact (n)<br>  (if (= n 0)<br>      1<br>    (* n (fact (- n 1)))))<br><br>(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))<br><br>(fdef fib (n)<br>  (if (= n 0)<br>      0<br>    (if (= n 1)<br>        1<br>      (+ (fib (- n 1)) (fib (- n 2))))))<br><br>(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))</pre>
    <p>Here is an example of a documented EVLambda source file:</p>
    <pre class="repl">&lt;chapter&gt;<br>&lt;title&gt;Recursive Functions&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;section&gt;<br>&lt;title&gt;Factorial Function&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>(fdef fact (n)<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  (if (= n 0)<br>      1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (* n (fact (- n 1))))) &lt;comment&gt;...eoll...&lt;/comment&gt;<br><br>(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))<br>&lt;/section&gt;<br>&lt;section&gt;<br>&lt;title&gt;Fibonacci Sequence&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>(fdef fib (n)<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  (if (= n 0)<br>      0 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (if (= n 1)<br>        1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>      (+ (fib (- n 1)) (fib (- n 2)))))) &lt;comment&gt;...eoll...&lt;/comment&gt;<br><br>(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))<br>&lt;/section&gt;<br>&lt;/chapter&gt;</pre>
    <p>Documented EVLambda source files can be converted to HTML by a component of the programming language called the documentation generator.</p>
    <h4>Extensible Markup Language (XML)</h4>
    <p>An <a href="https://en.wikipedia.org/wiki/XML" target="_blank">extensible markup language</a> (XML) document is a annotated text document. An XML document is divided into two intermingled parts: the character data (the content) and the markup (the annotations). Markup can take many forms. Documented EVLambda source files use the following forms of markup:</p>
    <dl>
      <dt>start tags (without attributes)</dt>
      <dd><code>&lt;chapter&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;title&gt;</code>, <code>&lt;para&gt;</code>, <code>&lt;comment&gt;</code>, &hellip;</dd>
      <dt>end tags</dt>
      <dd><code>&lt;/chapter&gt;</code>, <code>&lt;/section&gt;</code>, <code>&lt;/title&gt;</code>, <code>&lt;/para&gt;</code>, <code>&lt;/comment&gt;</code>, &hellip;</dd>
      <dt>empty-element tags (without attributes)</dt>
      <dd><code>&lt;br/&gt;</code>, &hellip;</dd>
      <dt>comments</dt>
      <dd><code>&lt;!-- FIXME --&gt;</code>, &hellip;</dd>
      <dt>entity references</dt>
      <dd><code>&amp;lt;</code> (refers to the character &lt;), <code>&amp;gt;</code> (refers to the character &gt;), <code>&amp;amp;</code> (refers to the character &amp;), &hellip;</dd>
      <dt>character references (decimal representation)</dt>
      <dd><code>&amp;#9166;</code> (refers to the character &#9166;), &hellip;</dd>
      <dt>character references (hexadecimal representation)</dt>
      <dd><code>&amp;#x23CE;</code> (refers to the character &#x23CE;), &hellip;</dd>
    </dl>
    <p>Many constraints must be satisfied for an XML document to be well-formed. The main well-formedness constraints are noted below.</p>
    <p><b>Well-formedness constraint:</b> Start tags and end tags must appear in pairs. In each pair, the start tag must precede the end tag and both tags must have the same name.</p>
    <p>An element is a sequence of characters delimited by a pair of start and end tags or by an empty-element tag. The characters of the delimiting tags or tag belong to the element. The characters that belong to an element but not to its delimiting tags or tag constitute the content of the element. The content of an element delimited by an empty-element tag is empty. The name of an element is the name of its delimiting tags or tag.</p>
    <p><b>Well-formedness constraint:</b> Elements must not overlap. Let $X$ and $Y$ be two distinct elements. One of the following conditions must be true: $X$ precedes $Y$, $Y$ precedes $X$, $X$ is inside the content of $Y$, or $Y$ is inside the content of $X$.</p>
    <p>Let $X$ and $Y$ be two elements. If $X$ is inside the content of $Y$ and there does not exist a third element $Z$ such that $X$ is inside the content of $Z$ and $Z$ is inside the content of $Y$, then $X$ is called a child of $Y$.</p>
    <p>Let $X$, $Y$, and $Z$ be three elements. If $X$ is a child of $Y$ and $Z$, then $Y$ and $Z$ are the same element. That element is called the parent of $X$.</p>
    <p>Not all elements have a parent. An element that has no parent is called a root element.</p>
    <p><b>Well-formedness constraint:</b> There must exist exactly one root element.</p>
    <p><b>Well-formedness constraint:</b> The characters &lt; and &amp; must not appear literally inside character data. They must be escaped using an entity reference or a character reference.</p>
    <p>Documented EVLambda source files are structured as follows:</p>
    <ul>
      <li>The root element is a chapter element.</li>
      <li>The chapter element must contain a child title element and may contain any number of child section and paragraph-level elements. The chapter element may also directly contain character data, which will be interpreted as EVLambda source code.</li>
      <li>The section elements must contain a child title element and may contain any number of child section and paragraph-level elements. The section elements may also directly contain character data, which will be interpreted as EVLambda source code.</li>
      <li>The only character data to be interpreted as EVLambda source code is the character data directly contained inside a chapter or section element.</li>
      <li>EVLambda source code can contain comments in XML format: block comments (in the form of paragraph-level elements), end-of-line comments (in the form of comment elements), and end-of-last-line comments (also in the form of comment elements). End-of-last-line comments are special because they are located outside the piece of code they are logically connected to. (They are located after the last closing parenthesis.)</li>
    </ul>
    <p>Because the characters &lt; and &amp; can appear inside EVLambda source code, a documented EVLambda source file is not always a well-formed XML document.</p>
    <h4>Documentation Generator</h4>
    <p>The documentation generator converts a documented EVLambda source file to HTML in two steps:</p>
    <p><b>Step 1</b> The characters &lt; and &amp; appearing inside EVLambda source code are escaped and some tags are added to better delimit the EVLambda source code and the comments. The resulting file is a well-formed XML document.</p>
    <p><b>Step 2</b> The resulting file from step 1 is converted to HTML by an XSLT stylesheet.</p>
    <h4>Unicode</h4>
    <p>The characters contained inside listener buffers and EVLambda source files are <a href="https://en.wikipedia.org/wiki/Unicode" target="_blank">Unicode</a> characters. Unicode is a character set containing, as of version 17.0, $159801$ characters. Each Unicode character is uniquely identified by a nonnegative integer called its code point. Code points range from $0$ to $1114111$ in decimal and from <code>0</code> to <code>10FFFF</code> in hexadecimal. (Not all code points are assigned to a character.) The notation $U{+}\mlvar{hex}$ denotes the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$. The order on integers directly translates into an order on Unicode characters. With respect to that order, the Unicode character $c_1$ precedes the Unicode character $c_2$ if and only if the code point of $c_1$ is strictly less than the code point of $c_2$. That order can be used to define ranges of Unicode characters.</p>
    <p>The range from $0$ to $1114111$ is divided into $17$ planes each containing $65536$ code points. The first plane is called the basic multilingual plane (BMP) and the other planes are called the supplementary planes. Most of the characters in common use in the world are located in the BMP.</p>
    <p>An encoding form is a mapping that maps a character to a sequence of $n$-bit words called code units. The following encoding forms are in common use:</p>
    <ul>
      <li>UTF-$32$: Code units are $32$-bit words and each character is mapped to a sequence of one code unit. Each character is mapped to the $32$-bit unsigned integer representing the character's code point.</li>
      <li>UTF-$16$: Code units are $16$-bit words and each character is mapped to a sequence of one or two code units. Each character belonging to the BMP is mapped to the $16$-bit unsigned integer representing the character's code point. Each character belonging to a supplementary plane is mapped to a sequence of two code units called a surrogate pair. The first element is called the high-surrogate code unit and the second element is called the low-surrogate code unit.</li>
      <li>UTF-$8$: Code units are $8$-bit words and each character is mapped to a sequence of one, two, three, or four code units. Each character belonging to the BMP is mapped to a sequence of one, two, or three code units. In particular, each of the $128$ ASCII characters is mapped to the $8$-bit unsigned integer representing the character's code point. Each character belonging to a supplementary plane is mapped to a sequence of four code units.</li>
    </ul>
    <p>An encoding scheme is a mapping that maps a character to a sequence of bytes. (A byte is an $8$-bit word.) The following encoding schemes are in common use:</p>
    <ul>
      <li>UTF-$32$BE: UTF-$32$ encoding form where each $32$-bit code unit is represented by four bytes ordered from most significant to least significant (big-endian order).</li>
      <li>UTF-$32$LE: UTF-$32$ encoding form where each $32$-bit code unit is represented by four bytes ordered from least significant to most significant (little-endian order).</li>
      <li>UTF-$16$BE: UTF-$16$ encoding form where each $16$-bit code unit is represented by two bytes ordered from most significant to least significant (big-endian order).</li>
      <li>UTF-$16$LE: UTF-$16$ encoding form where each $16$-bit code unit is represented by two bytes ordered from least significant to most significant (little-endian order).</li>
      <li>UTF-$8$: Because UTF-$8$ code units are bytes, UTF-$8$ is both an encoding form and an encoding scheme.</li>
    </ul>
    <p>Contrary to what was said in the user manual, an object of type <code>character</code> represents a UTF-$16$ code unit (instead of a Unicode character) and an object of type <code>string</code> represents an indexed sequence of UTF-$16$ code units (instead of an indexed sequence of Unicode characters).</p>
    <p>Each Unicode character has a name (&ldquo;LATIN CAPITAL LETTER A&rdquo; for instance) and a set of properties. An important property is the general category. The general category property can take the following values:</p>
    <table class="plain">
      <tr><td>Lu</td><td>Uppercase_Letter</td><td>uppercase letters</td></tr>
      <tr><td>Ll</td><td>Lowercase_Letter</td><td>lowercase letters</td></tr>
      <tr><td>Lt</td><td>Titlecase_Letter</td><td>digraphs whose first constituent is an uppercase letter</td></tr>
      <tr><td>LC</td><td>Cased_Letter</td><td>Lu, Ll, or Lt</td></tr>
      <tr><td>Lm</td><td>Modifier_Letter</td><td>noncombining modifier letters</td></tr>
      <tr><td>Lo</td><td>Other_Letter</td><td>letters from unicase alphabets and ideographs</td></tr>
      <tr><td>L</td><td>Letter</td><td>Lu, Ll, Lt, Lm, or Lo</td></tr>
      <tr><td>Mn</td><td>Nonspacing_Mark</td><td>nonspacing combining marks (accents, &hellip;)</td></tr>
      <tr><td>Mc</td><td>Spacing_Mark</td><td>spacing combining marks</td></tr>
      <tr><td>Me</td><td>Enclosing_Mark</td><td>enclosing combining marks</td></tr>
      <tr><td>M</td><td>Mark</td><td>Mn, Mc, or Me</td></tr>
      <tr><td>Nd</td><td>Decimal_Number</td><td>decimal digits</td></tr>
      <tr><td>Nl</td><td>Letter_Number</td><td>letterlike numeric characters (Roman numerals, &hellip;)</td></tr>
      <tr><td>No</td><td>Other_Number</td><td>other numeric characters (fractions, &hellip;)</td></tr>
      <tr><td>N</td><td>Number</td><td>Nd, Nl, or No</td></tr>
      <tr><td>Pc</td><td>Connector_Punctuation</td><td>connecting punctuation marks (underscore, &hellip;)</td></tr>
      <tr><td>Pd</td><td>Dash_Punctuation</td><td>dashlike punctuation marks (hyphen, dashes, &hellip;)</td></tr>
      <tr><td>Ps</td><td>Open_Punctuation</td><td>opening punctuation marks (opening parenthesis, &hellip;)</td></tr>
      <tr><td>Pe</td><td>Close_Punctuation</td><td>closing punctuation marks (closing parenthesis, &hellip;)</td></tr>
      <tr><td>Pi</td><td>Initial_Punctuation</td><td>initial quotation marks</td></tr>
      <tr><td>Pf</td><td>Final_Punctuation</td><td>final quotation marks</td></tr>
      <tr><td>Po</td><td>Other_Punctuation</td><td>other punctuation marks (period, comma, colon, semicolon, &hellip;)</td></tr>
      <tr><td>P</td><td>Punctuation</td><td>Pc, Pd, Ps, Pe, Pi, Pf, or Po</td></tr>
      <tr><td>Sm</td><td>Math_Symbol</td><td>mathematical symbols</td></tr>
      <tr><td>Sc</td><td>Currency_Symbol</td><td>currency symbols</td></tr>
      <tr><td>Sk</td><td>Modifier_Symbol</td><td>noncombining modifier symbols</td></tr>
      <tr><td>So</td><td>Other_Symbol</td><td>other symbols (Emojis, &hellip;)</td></tr>
      <tr><td>S</td><td>Symbol</td><td>Sm, Sc, Sk, or So</td></tr>
      <tr><td>Zs</td><td>Space_Separator</td><td>space characters</td></tr>
      <tr><td>Zl</td><td>Line_Separator</td><td>line separator character</td></tr>
      <tr><td>Zp</td><td>Paragraph_Separator</td><td>paragraph separator character</td></tr>
      <tr><td>Z</td><td>Separator</td><td>Zs, Zl, or Zp</td></tr>
      <tr><td>Cc</td><td>Control</td><td>C0 and C1 control characters (horizontal tab, line feed, carriage return, &hellip;)</td></tr>
      <tr><td>Cf</td><td>Format</td><td>format control characters (left-to-right and right-to-left marks, &hellip;)</td></tr>
      <tr><td>Cs</td><td>Surrogate</td><td>surrogate code points</td></tr>
      <tr><td>Co</td><td>Private_Use</td><td>private-use characters</td></tr>
      <tr><td>Cn</td><td>Unassigned</td><td>noncharacters and unassigned code points</td></tr>
      <tr><td>C</td><td>Other</td><td>Cc, Cf, Cs, Co, or Cn</td></tr>
    </table>
    <p>Most Unicode characters have associated visual representations called glyphs. For instance, the Unicode character &ldquo;LATIN CAPITAL LETTER A&rdquo; ($\unicode{0041}$) has the following associated glyphs (and infinitely more considering all possible variations in font, size, weight, style, etc.):</p>
    <ul>
      <li><span style="font: normal 1.5em serif;">A</span> (serif)</li>
      <li><span style="font: bold italic 1.5em serif;">A</span> (serif bold italic)</li>
      <li><span style="font: normal 1.5em sans-serif;">A</span> (sans-serif)</li>
      <li><span style="font: bold italic 1.5em sans-serif;">A</span> (sans-serif bold italic)</li>
    </ul>
    <p>In general, the association is not between Unicode characters and glyphs but between sequences of Unicode characters and glyphs and it is possible for different sequences of Unicode characters to have the same associated glyphs. For example, the sequence of one Unicode character &ldquo;LATIN CAPITAL LETTER A WITH DIAERESIS&rdquo; ($\unicode{00C4}$) and the sequence of two Unicode characters &ldquo;LATIN CAPITAL LETTER A&rdquo; ($\unicode{0041}$) &ldquo;COMBINING DIAERESIS&rdquo; ($\unicode{0308}$) have the same associated glyphs:</p>
    <ul>
      <li><span style="font: normal 1em serif;">&#x00C4;</span>, <span style="font: bold italic 1em serif;">&#x00C4;</span>, <span style="font: normal 1em sans-serif;">&#x00C4;</span>, <span style="font: bold italic 1em sans-serif;">&#x00C4;</span>, &hellip; ($\unicode{00C4}$)</li>
      <li><span style="font: normal 1em serif;">&#x0041;&#x0308;</span>, <span style="font: bold italic 1em serif;">&#x0041;&#x0308;</span>, <span style="font: normal 1em sans-serif;">&#x0041;&#x0308;</span>, <span style="font: bold italic 1em sans-serif;">&#x0041;&#x0308;</span>, &hellip; ($\unicode{0041}$ $\unicode{0308}$)</li>
    </ul>
    <h4>Regular Expressions</h4>
    <p>The tokenizer uses <a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank">regular expressions</a> to specify the patterns associated with the token categories.</p>
    <h4>Extended Backus-Naur Form (EBNF)</h4>
    <p>The parser and the syntax analyzer use a variant of the <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank">extended Backus-Naur form</a> (EBNF) notation to specify various <a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank">context-free grammars</a>.</p>
    <h3>Tokenizer</h3>
    <p>The tokenizer converts an input sequence of Unicode characters into a sequence of tokens in two steps. During the first step, the tokenizer converts the input sequence of Unicode characters into a provisional sequence of tokens. During the second step, the tokenizer converts the provisional sequence of tokens into a final sequence of tokens.</p>
    <h4>Character Classes</h4>
    <p>Let us first define the following named regular expressions:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{valid-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>[\C{L}\C{M}\C{N}\C{P}\C{S}\C{Z}\U{09}-\U{0D}\U{85}\C{Cf}\C{Co}]</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{whitespace-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>[\U{09}-\U{0D}\U{20}\U{85}\U{200E}\U{200F}\U{2028}\U{2029}]</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{syntax-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>['`,"()#]</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{xml-name-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>[a-z]</code></td>
      </tr>
    </table>
    <p>Each of those named regular expressions specifies a class of Unicode characters.</p>
    <p>The whitespace characters are the following characters:</p>
    <ul>
      <li>The horizontal tab control character (HT, $\unicode{0009}$).</li>
      <li>The line feed control character (LF, $\unicode{000A}$).</li>
      <li>The vertical tab control character (VT, $\unicode{000B}$).</li>
      <li>The form feed control character (FF, $\unicode{000C}$).</li>
      <li>The carriage return control character (CR, $\unicode{000D}$).</li>
      <li>The space ($\unicode{0020}$).</li>
      <li>The next line control character (NEL, $\unicode{0085}$).</li>
      <li>The left-to-right mark ($\unicode{200E}$).</li>
      <li>The right-to-left mark ($\unicode{200F}$).</li>
      <li>The line separator ($\unicode{2028}$).</li>
      <li>The paragraph separator ($\unicode{2029}$).</li>
    </ul>
    <p>In Linux and macOS operating systems, an end of line is represented by an LF character. In Windows operating systems, an end of line is represented by a CR character followed by an LF character.</p>
    <p>From the definition of $\metavar{valid-char}$, we can infer that the input sequence of Unicode characters must not contain any of the following characters and code points:</p>
    <ul>
      <li>The C0 and C1 control characters other than HT, LF, VT, FF, CR, and NEL.</li>
      <li>The surrogate code points.</li>
      <li>The noncharacters.</li>
      <li><span class="strike">The unassigned code points.</span></li>
    </ul>
    <p>The unassigned code points are actually allowed by the current version of the code.</p>
    <h4>Tokenization First Step</h4>
    <p>During the first step, the tokenizer converts the input sequence of Unicode characters into a provisional sequence of tokens of the following categories (patterns are regular expressions):</p>
    <dl>
      <dt><code>whitespace</code></dt>
      <dd>Pattern: <code>$\metavar{whitespace-char}$+</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>quote</code></dt>
      <dd>Pattern: <code>"'"</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>quasiquote</code></dt>
      <dd>Pattern: <code>'`'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>unquote</code></dt>
      <dd>Pattern: <code>','</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>unquote-splicing</code></dt>
      <dd>Pattern: <code>',@'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>string</code></dt>
      <dd>Pattern: <code>'"' (($\metavar{valid-char}$ - ["\\\\]) | ('\\\\' [\\\\"tnvfr]) | ('\\\\U{' [a-fA-F0-9]+ '}'))* '"'</code></dd>
      <dd>Value: The backslash plays the role of an escape character. The escape sequences are interpreted as specified in the table below. The value is an object of type <code>string</code> representing the sequence of UTF-16 code units encoding the sequence of Unicode characters delimited by the double quotes (after interpretation of the escape sequences).</dd>
      <dt><code>opening-parenthesis</code></dt>
      <dd>Pattern: <code>'('</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>closing-parenthesis</code></dt>
      <dd>Pattern: <code>')'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>hash-opening-parenthesis</code></dt>
      <dd>Pattern: <code>'#('</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>hash-plus</code></dt>
      <dd>Pattern: <code>'#+'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>hash-minus</code></dt>
      <dd>Pattern: <code>'#-'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>void</code></dt>
      <dd>Pattern: <code>'#v'</code></dd>
      <dd>Value: The value is the single object of type <code>void</code>.</dd>
      <dt><code>boolean</code></dt>
      <dd>Pattern: <code>'#t' | '#f'</code></dd>
      <dd>Value: If the lexeme matches <code>'#t'</code>, then the value is the single object of type <code>boolean</code> representing true. If the lexeme matches <code>'#f'</code>, then the value is the single object of type <code>boolean</code> representing false.</dd>
      <dt><code>hash-string</code></dt>
      <dd>Pattern: <code>'#' [0-9]* '"' (($\metavar{valid-char}$ - ["\\\\]) | ('\\\\' [\\\\"tnvfr]) | ('\\\\U{' [a-fA-F0-9]+ '}'))* '"'</code></dd>
      <dd>Value: The backslash plays the role of an escape character. The escape sequences are interpreted as specified in the table below. The value is the sequence of UTF-16 code units encoding the sequence of Unicode characters delimited by the double quotes (after interpretation of the escape sequences). An optional decimal numeral can be provided between the hash and the opening double quote.</dd>
      <dt><code>xml-start-tag</code></dt>
      <dd>Pattern: <code>'&lt;' $\metavar{xml-name-char}$+ '&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>xml-end-tag</code></dt>
      <dd>Pattern: <code>'&lt;/' $\metavar{xml-name-char}$+ '&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>xml-empty-element-tag</code></dt>
      <dd>Pattern: <code>'&lt;' $\metavar{xml-name-char}$+ '/&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>xml-comment</code></dt>
      <dd>Pattern: <code>'&lt;!--' (($\metavar{valid-char}$ - '-') | ('-' ($\metavar{valid-char}$ - '-')))* '--&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>proto-token</code></dt>
      <dd>Pattern: <code>(($\metavar{valid-char}$ - ($\metavar{whitespace-char}$ | $\metavar{syntax-char}$ | '\\\\')) | ('\\\\' [\\\\&lt;]) | ('\\\\U{' [a-fA-F0-9]+ '}'))+</code></dd>
      <dd>Value: The backslash plays the role of an escape character. The escape sequences are interpreted as specified in the table below. The value is the lexeme after interpretation of the escape sequences.</dd>
    </dl>
    <p>An escape character is a character that modifies the meaning of the following characters. Together, an escape character and the characters whose meanings are modified by the escape character form an escape sequence.</p>
    <p>Escape sequences in lexemes associated with tokens of categories <code>string</code> and <code>hash-string</code> are interpreted as follows:</p>
    <table class="plain">
      <tr><th>Escape sequence</th><th>Meaning</th></tr>
      <tr><td><code>\\\\</code></td><td>the backslash</td></tr>
      <tr><td><code>\"</code></td><td>the double quote</td></tr>
      <tr><td><code>\t</code></td><td>the horizontal tab control character</td></tr>
      <tr><td><code>\n</code></td><td>the line feed control character</td></tr>
      <tr><td><code>\v</code></td><td>the vertical tab control character</td></tr>
      <tr><td><code>\f</code></td><td>the form feed control character</td></tr>
      <tr><td><code>\r</code></td><td>the carriage return control character</td></tr>
      <tr><td><code>\U{$\mlvar{hex}$}</code></td><td>the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$</td></tr>
    </table>
    <p>Escape sequences in lexemes associated with tokens of category <code>proto-token</code> are interpreted as follows:</p>
    <table class="plain">
      <tr><th>Escape sequence</th><th>Meaning</th></tr>
      <tr><td><code>\\\\</code></td><td>the backslash</td></tr>
      <tr><td><code>\&lt;</code></td><td>the less-than sign</td></tr>
      <tr><td><code>\U{$\mlvar{hex}$}</code></td><td>the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$</td></tr>
    </table>
    <p>Let $\mlvar{input}$ be the input sequence of Unicode characters. For any token $T$, let us denote by $\lex(T)$ the lexeme associated with $T$ and by $\pat(T)$ the pattern associated with $T$'s category. The tokenizer must find a sequence of tokens $\langle T_0,\ldots,T_{n-1}\rangle$ such that the following conditions are satisfied:</p>
    <ul>
      <li>$\lex(T_i)$ matches $\pat(T_i)$ for all $i$ from $0$ to $n-1$</li>
      <li>$\mlvar{input}=\lex(T_0)\ldots\lex(T_{n-1})$</li>
    </ul>
    <p>Because the meaning of a program cannot be ambiguous, there cannot exist more than one sequence of tokens satisfying the previous conditions for any given input. As the following examples demonstrate, the patterns alone do not provide this guarantee:</p>
    <ul>
      <li>The input <code class="bg">foobar</code> has many competing interpretations, including the following two:
        <ul>
          <li><code class="bg">foo</code><sub><code>proto-token</code></sub> <code class="bg">bar</code><sub><code>proto-token</code></sub></li>
          <li><code class="bg">foobar</code><sub><code>proto-token</code></sub> (this is the intended interpretation)</li>
        </ul>
      </li>
      <li>The input <code class="bg">,@foo</code> has many competing interpretations, including the following two:
        <ul>
          <li><code class="bg">,</code><sub><code>unquote</code></sub> <code class="bg">@foo</code><sub><code>proto-token</code></sub></li>
          <li><code class="bg">,@</code><sub><code>unquote-splicing</code></sub> <code class="bg">foo</code><sub><code>proto-token</code></sub> (this is the intended interpretation)</li>
        </ul>
      </li>
      <li>The input <code class="bg">foo&lt;bar&gt;baz</code> has many competing interpretations, including the following two:
        <ul>
          <li><code class="bg">foo&lt;bar&gt;baz</code><sub><code>proto-token</code></sub></li>
          <li><code class="bg">foo</code><sub><code>proto-token</code></sub> <code class="bg">&lt;bar&gt;</code><sub><code>xml-start-tag</code></sub> <code class="bg">baz</code><sub><code>proto-token</code></sub>(this is the intended interpretation)</li>
        </ul>
      </li>
    </ul>
    <p>The tokenizer uses additional rules to resolve the ambiguities. Those additional rules are embedded into the algorithm provided below.</p>
    <p>EVLambda source code can only be found outside any XML element (this is the case in listener buffers and plain EVLambda source files) or directly inside a <code>chapter</code> or <code>section</code> XML element (this is the case in documented EVLambda source files). A context that cannot contain EVLambda source code is called a pure-xml context. When processing a pure-xml context, the tokenizer only recognizes tokens of the following categories: <code>whitespace</code> (any character data is treated as whitespace when processing a pure-xml context), <code>xml-start-tag</code>, <code>xml-end-tag</code>, <code>xml-empty-element-tag</code>, and <code>xml-comment</code>. The tokenizer uses a stack of XML element names to determine if it is processing a pure-xml context. The tokenizer is processing a pure-xml context when the stack is not empty and the name at the top of the stack is neither <code>chapter</code> nor <code>section</code>.</p>
    <p>Here is the algorithm  used by the tokenizer to convert the input sequence of Unicode characters into a provisional sequence of tokens (control normally flows from one step to the next and it is assumed that the stack of XML element names is initially empty):</p>
    <ul>
      <li>If the context is pure-xml and the next character is not a less-than sign, emit a token of category <code>whitespace</code> whose associated lexeme contains all the characters up to the end of the input or the first character that is a less-than sign (that character is not included in the lexeme).</li>
      <li>If the context is not pure-xml and the next character is a whitespace character, emit a token of category <code>whitespace</code> whose associated lexeme contains all the characters up to the end of the input or the first character that is not a whitespace character (that character is not included in the lexeme).</li>
      <li>If the end of the input has been reached, stop.</li>
      <li>If the next character is a single quote, emit a token of category <code>quote</code> and loop to the top.</li>
      <li>If the next character is a backquote, emit a token of category <code>quasiquote</code> and loop to the top.</li>
      <li>If the next character is a comma followed by an at sign, emit a token of category <code>unquote-splicing</code> and loop to the top.</li>
      <li>If the next character is a comma, emit a token of category <code>unquote</code> and loop to the top.</li>
      <li>If the next character is a double quote, emit a token of category <code>string</code> whose associated lexeme contains all the charactes up to the first unescaped double quote (that character is included in the lexeme) and loop to the top. Fail if the lexeme contains an invalid escape sequence or the closing double quote is missing.</li>
      <li>If the next character is an opening parenthesis, emit a token of category <code>opening-parenthesis</code> and loop to the top.</li>
      <li>If the next character is a closing parenthesis, emit a token of category <code>closing-parenthesis</code> and loop to the top.</li>
      <li>If the next character is a hash followed by an opening parenthesis, emit a token of category <code>hash-opening-parenthesis</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a plus sign, emit a token of category <code>hash-plus</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a minus sign, emit a token of category <code>hash-minus</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a lowercase <code>v</code>, emit a token of category <code>void</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a lowercase <code>t</code>, emit a token of category <code>boolean</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a lowercase <code>f</code>, emit a token of category <code>boolean</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a sequence of zero or more decimal digits followed by a double quote, emit a token of category <code>hash-string</code> whose associated lexeme contains all the charactes up to the first unescaped double quote (that character is included in the lexeme) and loop to the top. Fail if the lexeme contains an invalid escape sequence or the closing double quote is missing.</li>
      <li>If the next character is a hash, fail.</li>
      <li>If the next character is a less-than sign that is the first character of an XML start tag, emit a token of category <code>xml-start-tag</code>, push the name of the start tag on the stack, and loop to the top.</li>
      <li>If the next character is a less-than sign that is the first character of an XML end tag, emit a token of category <code>xml-end-tag</code>, pop the top name off the stack, and loop to the top. Fail if the stack is empty or the top name does not match the name of the end tag.</li>
      <li>If the next character is a less-than sign that is the first character of an XML empty-element tag, emit a token of category <code>xml-empty-element-tag</code> and loop to the top.</li>
      <li>If the next character is a less-than sign that is the first character of an XML comment, emit a token of category <code>xml-comment</code> and loop to the top.</li>
      <li>If the context is pure-xml, fail.</li>
      <li>(The next character is neither a whitespace character, nor a syntax character, nor a less-than sign that is the first character of a piece of XML markup.) Emit a token of category <code>proto-token</code> whose associated lexeme contains all the characters up to the end of the input or the first character that is a whitespace character, a syntax character, or an unescaped less-than sign that is the first character of a piece of XML markup (that character is not included in the lexeme) and loop to the top. Fail if the lexeme contains an invalid escape sequence.</li>
    </ul>
    <h4>Tokenization Second Step</h4>
    <p>During the second step, the tokenizer converts the provisional sequence of tokens into a final sequence of tokens as follows:</p>
    <ul>
      <li>The tokens of category <code>whitespace</code> are discarded.</li>
      <li>Each token of category <code>hash-string</code> is processed as follows:
        <ul>
          <li>Case 1, the optional decimal numeral is not provided: Let $\langle\mlvar{code-unit}_0,\ldots,\mlvar{code-unit}_{n-1}\rangle$ be the value of the token of category <code>hash-string</code>. The token of category <code>hash-string</code> is replaced by a sequence of $n$ token(s) of category <code>character</code> such that the value of the $i$-th token of category <code>character</code> is an object of type <code>character</code> representing $\mlvar{code-unit}_i$.</li>
          <li>Case 2, the optional decimal numeral is provided: Let $\langle\mlvar{code-unit}_0,\ldots,\mlvar{code-unit}_{n-1}\rangle$ be the value of the token of category <code>hash-string</code> and $i$ be the nonnegative integer represented by the optional decimal numeral. If $i\lt n$, then the token of category <code>hash-string</code> is replaced by a token of category <code>character</code> whose value is an object of type <code>character</code> representing $\mlvar{code-unit}_i$. Otherwise, the tokenization fails.</li>
        </ul>
      </li>
      <li>Each token of category <code>proto-token</code> is replaced by a token of one of the following categories (patterns are regular expressions matched against the value of the token of category <code>proto-token</code>; the first pattern matching the value wins; tokenization fails if no pattern matches the value):
        <dl>
          <dt><code>dot</code></dt>
          <dd>Pattern: <code>'.'</code></dd>
          <dd>Value: N/A</dd>
          <dt><code>number</code></dt>
          <dd>Pattern: <code>('+' | '-')? [0-9]+ ('.' [0-9]+)?</code></dd>
          <dd>Value: The value is an object of type <code>number</code> representing the mathematical number of which the value matching the pattern is a decimal representation.</dd>
          <dt><code>keyword</code></dt>
          <dd>Pattern: <code>':' [^:]+</code></dd>
          <dd>Value: The value is the object of type <code>keyword</code> whose name is the value matching the pattern.</dd>
          <dt><code>variable</code></dt>
          <dd>Pattern: <code>[^:]+</code></dd>
          <dd>Value: The value is the object of type <code>variable</code> whose name is the value matching the pattern.</dd>
        </dl>
      </li>
      <li>The tokens of other categories are retained without modification.</li>
    </ul>
    <h4>Ninjas</h4>
    <p>This section illustrates the use of the hash-string construct.</p>
    <p>The Unicode character &ldquo;NINJA&rdquo; ($\unicode{1F977}$, high-surrogate $\unicode{D83E}$, low-surrogate $\unicode{DD77}$) represents a ninja with a nonrealistic skin tone:</p>
    <pre class="repl">&gt; '(#"&#x1F977;")<br>(#"\U{D83E}" #"\U{DD77}")<br><br>&gt; #0"&#x1F977;"<br>#"\U{D83E}"<br><br>&gt; #1"&#x1F977;"<br>#"\U{DD77}"</pre>
    <p>It is possible to obtain a ninja with a realistic skin tone by combining the Unicode character "NINJA" with one of the following skin-tone modifiers:</p>
    <table class="plain">
      <tr><th>Name</th><th>Code Point</th><th>High-Surrogate</th><th>Low-Surrogate</th><th>Sample</th></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-1-2</td><td>$\unicode{1F3FB}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFB}$</td><td>&#x1F3FB;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-3</td><td>$\unicode{1F3FC}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFC}$</td><td>&#x1F3FC;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-4</td><td>$\unicode{1F3FD}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFD}$</td><td>&#x1F3FD;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-5</td><td>$\unicode{1F3FE}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFE}$</td><td>&#x1F3FE;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-6</td><td>$\unicode{1F3FF}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFF}$</td><td>&#x1F3FF;</td></tr>
    </table>
    <p>Here is the result of combining the Unicode character &ldquo;NINJA&rdquo; with the different skin-tone modifiers:</p>
    <pre class="repl">&gt; '(#"&#x1F977;&#x1F3FB;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFB}")<br><br>&gt; '(#"&#x1F977;&#x1F3FC;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFC}")<br><br>&gt; '(#"&#x1F977;&#x1F3FD;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFD}")<br><br>&gt; '(#"&#x1F977;&#x1F3FE;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFE}")<br><br>&gt; '(#"&#x1F977;&#x1F3FF;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFF}")<br><br></pre>
  </body>
</html>
