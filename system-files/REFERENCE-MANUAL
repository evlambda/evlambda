<!doctype html>
<!-- SPDX-FileCopyrightText: Copyright (c) 2024-2025 RaphaÃ«l Van Dyck -->
<!-- SPDX-License-Identifier: BSD-3-Clause -->
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="___cssURL___"/>
    <script src="___jsURL___"></script>
    <script>const windowId = ___windowId___;</script>
  </head>
  <body>
    <div class="preamble">
      $\newcommand{\unicode}[1]{U{+}\code{#1}}$
      $\DeclareMathOperator{\lex}{lex}$
      $\DeclareMathOperator{\pat}{pat}$
    </div>
    <h1>Reference Manual</h1>
    <p>The reference manual provides a detailed account of the programming language. It supplements and amends the user manual (particularly the sections &ldquo;Programming Language&rdquo; and &ldquo;Listener Buffers&rdquo;) and the tutorial.</p>
    <h2>Syntax</h2>
    <h3>Introduction</h3>
    <h4>Listener Buffers</h4>
    <p>Let's examine what happens when the form <code>(+ 123 456)</code> is evaluated in a listener buffer:</p>
    <pre class="repl">&gt; (+ 123 456)<br>579</pre>
    <p>The process can be broken down into the following five steps:</p>
    <p><b>Step 1</b> The sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> is read from the listener buffer.</p>
    <p><b>Step 2</b> The reader converts the sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> into the list <code>(+ 123 456)</code>. (The sequence of characters is a readable representation of the list.) This step can be broken down into the following two substeps:</p>
    <p><b>Step 2.1</b> A component of the reader called the tokenizer converts the sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> into a sequence of tokens. A token consists of the following pieces of information bundled together: a category and, if required by the category, a value. Each token category has an associated pattern and each token has an associated lexeme. A lexeme is a sequence of contiguous characters extracted from the input sequence of characters. The lexeme associated with a token must match the pattern associated with the token's category and the sequence of characters resulting from the concatenation of the lexemes associated with the tokens must match the input sequence of characters. The sequence of characters <span class="charseq"><span class="char">(</span><span class="char">+</span><span class="char">&nbsp;</span><span class="char">1</span><span class="char">2</span><span class="char">3</span><span class="char">&nbsp;</span><span class="char">4</span><span class="char">5</span><span class="char">6</span><span class="char">)</span></span> is converted into the following sequence of tokens:</p>
    <ul>
      <li>A token of category <code>opening-parenthesis</code> whose associated lexeme is <span class="charseq"><span class="char">(</span></span>. This token has no value.</li>
      <li>A token of category <code>variable</code> whose associated lexeme is <span class="charseq"><span class="char">+</span></span>. The value of this token is the object of type <code>variable</code> whose name is <span class="charseq"><span class="char">+</span></span>.</li>
      <li>A token of category <code>whitespace</code> whose associated lexeme is <span class="charseq"><span class="char">&nbsp;</span></span>. This token has no value.</li>
      <li>A token of category <code>number</code> whose associated lexeme is <span class="charseq"><span class="char">1</span><span class="char">2</span><span class="char">3</span></span>. The value of this token is an object of type <code>number</code> representing the mathematical number $123$.</li>
      <li>A token of category <code>whitespace</code> whose associated lexeme is <span class="charseq"><span class="char">&nbsp;</span></span>. This token has no value.</li>
      <li>A token of category <code>number</code> whose associated lexeme is <span class="charseq"><span class="char">4</span><span class="char">5</span><span class="char">6</span></span>. The value of this token is an object of type <code>number</code> representing the mathematical number $456$.</li>
      <li>A token of category <code>closing-parenthesis</code> whose associated lexeme is <span class="charseq"><span class="char">)</span></span>. This token has no value.</li>
    </ul>
    <p>Note that some whitespace is needed to separate the lexeme <span class="charseq"><span class="char">+</span></span> from the lexeme <span class="charseq"><span class="char">1</span><span class="char">2</span><span class="char">3</span></span> and the lexeme <span class="charseq"><span class="char">1</span><span class="char">2</span><span class="char">3</span></span> from the lexeme <span class="charseq"><span class="char">4</span><span class="char">5</span><span class="char">6</span></span> but no whitespace is needed to separate the lexeme <span class="charseq"><span class="char">(</span></span> from the lexeme <span class="charseq"><span class="char">+</span></span> or the lexeme <span class="charseq"><span class="char">4</span><span class="char">5</span><span class="char">6</span></span> from the lexeme <span class="charseq"><span class="char">)</span></span>.</p>
    <p><b>Step 2.2</b> A component of the reader called the parser converts the sequence of tokens from step 2.1 (minus the tokens of category <code>whitespace</code>, which are ignored by the parser) into a cons whose car is the variable from step 2.1 and whose cdr is a cons whose car is the first number from step 2.1 and whose cdr is a cons whose car is the second number from step 2.1 and whose cdr is the empty list. Together, those three conses represent the list <code>(+ 123 456)</code>.</p>
    <p><b>Step 3</b> The evaluator evaluates the list <code>(+ 123 456)</code> to the number <code>579</code>. The evaluation of the top-level form <code>(+ 123 456)</code> entails the evaluation of other non-top-level forms. Each form must be classified in order to determine how it should be evaluated. The form <code>(+ 123 456)</code> is classified as a plain function call. The variable <code>+</code> is treated as an abbreviation for the form <code>(fref +)</code>. The form <code>(fref +)</code> is classified as an fref-form. The forms <code>123</code> and <code>456</code> are classified as self-evaluating objects. Because the global function <code>+</code> is a closure, its invocation entails the evaluation (and thus the classification) of other forms. The component of the evaluator responsible for classifying forms is called the syntax analyzer.</p>
    <p><b>Step 4</b> The printer converts the number <code>579</code> into the sequence of characters <span class="charseq"><span class="char">5</span><span class="char">7</span><span class="char">9</span></span>. (The sequence of characters is the printable representation of the number.)</p>
    <p><b>Step 5</b> The sequence of characters <span class="charseq"><span class="char">5</span><span class="char">7</span><span class="char">9</span></span> is written into the listener buffer.</p>
    <p>EVLambda has three levels of syntax:</p>
    <ul>
      <li>The token level contains the rules used by the tokenizer to convert a sequence of characters into a sequence of tokens.</li>
      <li>The object level contains the rules used by the parser to convert a sequence of tokens into a sequence of objects.</li>
      <li>The form level contains the rules used by the syntax analyzer to classify forms.</li>
    </ul>
    <p>Each level of syntax is described later in its own section.</p>
    <h4>EVLambda Source Files</h4>
    <p>The reader is used not only to convert the characters typed into a listener buffer into an object but also to convert the characters contained inside an EVLambda source file into a sequence of objects.</p>
    <p>EVLambda source files come in two varieties: the plain EVLambda source files, which contain only EVLambda source code, and the documented EVLambda source files, which contain a mix of EVLambda source code and documentation in XML format.</p>
    <p>Here is an example of a plain EVLambda source file:</p>
    <pre class="repl">(fdef fact (n)<br>  (if (= n 0)<br>      1<br>    (* n (fact (- n 1)))))<br><br>(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))<br><br>(fdef fib (n)<br>  (if (= n 0)<br>      0<br>    (if (= n 1)<br>        1<br>      (+ (fib (- n 1)) (fib (- n 2))))))<br><br>(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))</pre>
    <p>Here is an example of a documented EVLambda source file:</p>
    <pre class="repl">&lt;chapter&gt;<br>&lt;title&gt;Recursive Functions&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;section&gt;<br>&lt;title&gt;Factorial Function&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>(fdef fact (n)<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  (if (= n 0)<br>      1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (* n (fact (- n 1))))) &lt;comment&gt;...eoll...&lt;/comment&gt;<br><br>(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))<br>&lt;/section&gt;<br>&lt;section&gt;<br>&lt;title&gt;Fibonacci Sequence&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>(fdef fib (n)<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  (if (= n 0)<br>      0 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (if (= n 1)<br>        1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>      (+ (fib (- n 1)) (fib (- n 2)))))) &lt;comment&gt;...eoll...&lt;/comment&gt;<br><br>(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))<br>&lt;/section&gt;<br>&lt;/chapter&gt;</pre>
    <p>Documented EVLambda source files can be converted to HTML by a component of the programming language called the documentation generator.</p>
    <h4>Extensible Markup Language (XML)</h4>
    <p>An <a href="https://en.wikipedia.org/wiki/XML" target="_blank">extensible markup language</a> (XML) document is a annotated text document. An XML document is divided into two intermingled parts: the character data (the content) and the markup (the annotations). Markup can take many forms. Documented EVLambda source files use the following forms of markup:</p>
    <dl>
      <dt>start tags (without attributes)</dt>
      <dd><code>&lt;chapter&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;title&gt;</code>, <code>&lt;para&gt;</code>, <code>&lt;comment&gt;</code>, &hellip;</dd>
      <dt>end tags</dt>
      <dd><code>&lt;/chapter&gt;</code>, <code>&lt;/section&gt;</code>, <code>&lt;/title&gt;</code>, <code>&lt;/para&gt;</code>, <code>&lt;/comment&gt;</code>, &hellip;</dd>
      <dt>empty-element tags (without attributes)</dt>
      <dd><code>&lt;br/&gt;</code>, &hellip;</dd>
      <dt>comments</dt>
      <dd><code>&lt;!-- FIXME --&gt;</code>, &hellip;</dd>
      <dt>entity references</dt>
      <dd><code>&amp;lt;</code> (refers to the character &lt;), <code>&amp;gt;</code> (refers to the character &gt;), <code>&amp;amp;</code> (refers to the character &amp;), &hellip;</dd>
      <dt>character references (decimal representation)</dt>
      <dd><code>&amp;#9166;</code> (refers to the character &#9166;), &hellip;</dd>
      <dt>character references (hexadecimal representation)</dt>
      <dd><code>&amp;#x23CE;</code> (refers to the character &#x23CE;), &hellip;</dd>
    </dl>
    <p>Many constraints must be satisfied for an XML document to be well-formed. The main well-formedness constraints are noted below.</p>
    <p><b>Well-formedness constraint:</b> Start tags and end tags must appear in pairs. In each pair, the start tag must precede the end tag and both tags must have the same name.</p>
    <p>An element is a sequence of characters delimited by a pair of start and end tags or by an empty-element tag. The characters of the delimiting tags or tag belong to the element. The characters that belong to an element but not to its delimiting tags or tag constitute the content of the element. The content of an element delimited by an empty-element tag is empty. The name of an element is the name of its delimiting tags or tag.</p>
    <p><b>Well-formedness constraint:</b> Elements must not overlap. Let $X$ and $Y$ be two distinct elements. One of the following conditions must be true: $X$ precedes $Y$, $Y$ precedes $X$, $X$ is inside the content of $Y$, or $Y$ is inside the content of $X$.</p>
    <p>Let $X$ and $Y$ be two elements. If $X$ is inside the content of $Y$ and there does not exist a third element $Z$ such that $X$ is inside the content of $Z$ and $Z$ is inside the content of $Y$, then $X$ is called a child of $Y$.</p>
    <p>Let $X$, $Y$, and $Z$ be three elements. If $X$ is a child of $Y$ and $Z$, then $Y$ and $Z$ are the same element. That element is called the parent of $X$.</p>
    <p>Not all elements have a parent. An element that has no parent is called a root element.</p>
    <p><b>Well-formedness constraint:</b> There must exist exactly one root element.</p>
    <p><b>Well-formedness constraint:</b> The characters &lt; and &amp; must not appear literally inside character data. They must be escaped using an entity reference or a character reference.</p>
    <p>Documented EVLambda source files are structured as follows:</p>
    <ul>
      <li>The root element is a chapter element.</li>
      <li>The chapter element must contain a child title element and may contain any number of child section and paragraph-level elements. The chapter element may also directly contain character data, which will be interpreted as EVLambda source code.</li>
      <li>The section elements must contain a child title element and may contain any number of child section and paragraph-level elements. The section elements may also directly contain character data, which will be interpreted as EVLambda source code.</li>
      <li>The only character data to be interpreted as EVLambda source code is the character data directly contained inside a chapter or section element.</li>
      <li>EVLambda source code can contain comments in XML format: block comments (in the form of paragraph-level elements), end-of-line comments (in the form of comment elements), and end-of-last-line comments (also in the form of comment elements). End-of-last-line comments are special because they are located outside the piece of code they are logically connected to. (They are located after the last closing parenthesis.)</li>
    </ul>
    <p>Because the characters &lt; and &amp; can appear inside EVLambda source code, a documented EVLambda source file is not always a well-formed XML document.</p>
    <h4>Documentation Generator</h4>
    <p>The documentation generator converts a documented EVLambda source file to HTML in two steps:</p>
    <p><b>Step 1</b> The characters &lt; and &amp; appearing inside EVLambda source code are escaped and some tags are added to better delimit the code from the surrounding documentation and the comments from the surrounding code. The resulting file is a well-formed XML document.</p>
    <p><b>Step 2</b> The resulting file from step 1 is converted to HTML by an XSLT stylesheet.</p>
    <h4>Unicode</h4>
    <p>The characters contained inside listener buffers and EVLambda source files are <a href="https://en.wikipedia.org/wiki/Unicode" target="_blank">Unicode</a> characters. Unicode is a character set containing, as of version 17.0, $159801$ characters. Each Unicode character is uniquely identified by a nonnegative integer called its code point. Code points range from $0$ to $1114111$ in decimal and from <code>0</code> to <code>10FFFF</code> in hexadecimal. (Not all code points are assigned to a character.) The notation $U{+}\mlvar{hex}$ denotes the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$. The order on integers directly translates into an order on Unicode characters. With respect to that order, the Unicode character $c_1$ precedes the Unicode character $c_2$ if and only if the code point of $c_1$ is strictly less than the code point of $c_2$. That order can be used to define ranges of Unicode characters.</p>
    <p>The range from $0$ to $1114111$ is divided into $17$ planes each containing $65536$ code points. The first plane is called the basic multilingual plane (BMP) and the other planes are called the supplementary planes. Most of the characters in common use in the world are located in the BMP.</p>
    <p>An encoding form is a mapping that maps a character to a sequence of $n$-bit words called code units. The following encoding forms are in common use:</p>
    <ul>
      <li>UTF-$32$: Code units are $32$-bit words and each character is mapped to a sequence of one code unit. Each character is mapped to the $32$-bit unsigned integer representing the character's code point.</li>
      <li>UTF-$16$: Code units are $16$-bit words and each character is mapped to a sequence of one or two code units. Each character belonging to the BMP is mapped to the $16$-bit unsigned integer representing the character's code point. Each character belonging to a supplementary plane is mapped to a sequence of two code units called a surrogate pair. The first element is called the high-surrogate code unit and the second element is called the low-surrogate code unit.</li>
      <li>UTF-$8$: Code units are $8$-bit words and each character is mapped to a sequence of one, two, three, or four code units. Each character belonging to the BMP is mapped to a sequence of one, two, or three code units. In particular, each of the $128$ ASCII characters is mapped to the $8$-bit unsigned integer representing the character's code point. Each character belonging to a supplementary plane is mapped to a sequence of four code units.</li>
    </ul>
    <p>An encoding scheme is a mapping that maps a character to a sequence of bytes. (A byte is an $8$-bit word.) The following encoding schemes are in common use:</p>
    <ul>
      <li>UTF-$32$BE: UTF-$32$ encoding form where each $32$-bit code unit is represented by four bytes ordered from most significant to least significant (big-endian order).</li>
      <li>UTF-$32$LE: UTF-$32$ encoding form where each $32$-bit code unit is represented by four bytes ordered from least significant to most significant (little-endian order).</li>
      <li>UTF-$16$BE: UTF-$16$ encoding form where each $16$-bit code unit is represented by two bytes ordered from most significant to least significant (big-endian order).</li>
      <li>UTF-$16$LE: UTF-$16$ encoding form where each $16$-bit code unit is represented by two bytes ordered from least significant to most significant (little-endian order).</li>
      <li>UTF-$8$: Because UTF-$8$ code units are bytes, UTF-$8$ is both an encoding form and an encoding scheme.</li>
    </ul>
    <p>Contrary to what was said in the user manual, an object of type <code>character</code> represents a UTF-$16$ code unit (instead of a Unicode character) and an object of type <code>string</code> represents an indexed sequence of UTF-$16$ code units (instead of an indexed sequence of Unicode characters).</p>
    <p>Each Unicode character has a name (&ldquo;LATIN CAPITAL LETTER A&rdquo; for instance) and a set of properties. An important property is the general category. The general category property can take the following values:</p>
    <table class="plain">
      <tr><td>Lu</td><td>Uppercase_Letter</td><td>uppercase letters</td></tr>
      <tr><td>Ll</td><td>Lowercase_Letter</td><td>lowercase letters</td></tr>
      <tr><td>Lt</td><td>Titlecase_Letter</td><td>digraphs whose first constituent is an uppercase letter</td></tr>
      <tr><td>LC</td><td>Cased_Letter</td><td>Lu, Ll, or Lt</td></tr>
      <tr><td>Lm</td><td>Modifier_Letter</td><td>noncombining modifier letters</td></tr>
      <tr><td>Lo</td><td>Other_Letter</td><td>letters from unicase alphabets and ideographs</td></tr>
      <tr><td>L</td><td>Letter</td><td>Lu, Ll, Lt, Lm, or Lo</td></tr>
      <tr><td>Mn</td><td>Nonspacing_Mark</td><td>nonspacing combining marks (accents, &hellip;)</td></tr>
      <tr><td>Mc</td><td>Spacing_Mark</td><td>spacing combining marks</td></tr>
      <tr><td>Me</td><td>Enclosing_Mark</td><td>enclosing combining marks</td></tr>
      <tr><td>M</td><td>Mark</td><td>Mn, Mc, or Me</td></tr>
      <tr><td>Nd</td><td>Decimal_Number</td><td>decimal digits</td></tr>
      <tr><td>Nl</td><td>Letter_Number</td><td>letterlike numeric characters (Roman numerals, &hellip;)</td></tr>
      <tr><td>No</td><td>Other_Number</td><td>other numeric characters (fractions, &hellip;)</td></tr>
      <tr><td>N</td><td>Number</td><td>Nd, Nl, or No</td></tr>
      <tr><td>Pc</td><td>Connector_Punctuation</td><td>connecting punctuation marks (underscore, &hellip;)</td></tr>
      <tr><td>Pd</td><td>Dash_Punctuation</td><td>dashlike punctuation marks (hyphen, dashes, &hellip;)</td></tr>
      <tr><td>Ps</td><td>Open_Punctuation</td><td>opening punctuation marks (opening parenthesis, &hellip;)</td></tr>
      <tr><td>Pe</td><td>Close_Punctuation</td><td>closing punctuation marks (closing parenthesis, &hellip;)</td></tr>
      <tr><td>Pi</td><td>Initial_Punctuation</td><td>initial quotation marks</td></tr>
      <tr><td>Pf</td><td>Final_Punctuation</td><td>final quotation marks</td></tr>
      <tr><td>Po</td><td>Other_Punctuation</td><td>other punctuation marks (period, comma, colon, semicolon, &hellip;)</td></tr>
      <tr><td>P</td><td>Punctuation</td><td>Pc, Pd, Ps, Pe, Pi, Pf, or Po</td></tr>
      <tr><td>Sm</td><td>Math_Symbol</td><td>mathematical symbols</td></tr>
      <tr><td>Sc</td><td>Currency_Symbol</td><td>currency symbols</td></tr>
      <tr><td>Sk</td><td>Modifier_Symbol</td><td>noncombining modifier symbols</td></tr>
      <tr><td>So</td><td>Other_Symbol</td><td>other symbols (Emojis, &hellip;)</td></tr>
      <tr><td>S</td><td>Symbol</td><td>Sm, Sc, Sk, or So</td></tr>
      <tr><td>Zs</td><td>Space_Separator</td><td>space characters</td></tr>
      <tr><td>Zl</td><td>Line_Separator</td><td>line separator character</td></tr>
      <tr><td>Zp</td><td>Paragraph_Separator</td><td>paragraph separator character</td></tr>
      <tr><td>Z</td><td>Separator</td><td>Zs, Zl, or Zp</td></tr>
      <tr><td>Cc</td><td>Control</td><td>C0 and C1 control characters (horizontal tab, line feed, carriage return, &hellip;)</td></tr>
      <tr><td>Cf</td><td>Format</td><td>format control characters (left-to-right and right-to-left marks, &hellip;)</td></tr>
      <tr><td>Cs</td><td>Surrogate</td><td>surrogate code points</td></tr>
      <tr><td>Co</td><td>Private_Use</td><td>private-use characters</td></tr>
      <tr><td>Cn</td><td>Unassigned</td><td>noncharacters and unassigned code points</td></tr>
      <tr><td>C</td><td>Other</td><td>Cc, Cf, Cs, Co, or Cn</td></tr>
    </table>
    <p>Most Unicode characters have associated visual representations called glyphs. For instance, the Unicode character &ldquo;LATIN CAPITAL LETTER A&rdquo; ($\unicode{0041}$) has the following associated glyphs (and infinitely more considering all possible variations in font, size, weight, style, etc.):</p>
    <ul>
      <li><span style="font: normal 1.5em serif;">A</span> (serif)</li>
      <li><span style="font: bold italic 1.5em serif;">A</span> (serif bold italic)</li>
      <li><span style="font: normal 1.5em sans-serif;">A</span> (sans-serif)</li>
      <li><span style="font: bold italic 1.5em sans-serif;">A</span> (sans-serif bold italic)</li>
    </ul>
    <p>In general, the association is not between Unicode characters and glyphs but between sequences of Unicode characters and glyphs and it is possible for different sequences of Unicode characters to have the same associated glyphs. For example, the sequence of one Unicode character &ldquo;LATIN CAPITAL LETTER A WITH DIAERESIS&rdquo; ($\unicode{00C4}$) and the sequence of two Unicode characters &ldquo;LATIN CAPITAL LETTER A&rdquo; ($\unicode{0041}$) &ldquo;COMBINING DIAERESIS&rdquo; ($\unicode{0308}$) have the same associated glyphs:</p>
    <ul>
      <li><span style="font: normal 1em serif;">&#x00C4;</span>, <span style="font: bold italic 1em serif;">&#x00C4;</span>, <span style="font: normal 1em sans-serif;">&#x00C4;</span>, <span style="font: bold italic 1em sans-serif;">&#x00C4;</span>, &hellip; ($\unicode{00C4}$)</li>
      <li><span style="font: normal 1em serif;">&#x0041;&#x0308;</span>, <span style="font: bold italic 1em serif;">&#x0041;&#x0308;</span>, <span style="font: normal 1em sans-serif;">&#x0041;&#x0308;</span>, <span style="font: bold italic 1em sans-serif;">&#x0041;&#x0308;</span>, &hellip; ($\unicode{0041}$ $\unicode{0308}$)</li>
    </ul>
    <h4>Regular Expressions</h4>
    <p>The tokenizer uses <a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank">regular expressions</a> to specify the patterns associated with the token categories.</p>
    <p>The following table summarizes the syntax of the regular expressions used in this document:</p>
    <table class="plain">
      <tr><th>Syntax</th><th>Meaning</th></tr>
      <tr><td><code>'&hellip;'</code></td><td>literal string (literal single quotes and backslashes must be escaped)</td></tr>
      <tr><td><code>"&hellip;"</code></td><td>literal string (literal double quotes and backslashes must be escaped)</td></tr>
      <tr><td><code>[&hellip;]</code></td><td>positive character class (literal carets, hyphens, closing square brackets, and backslashes must be escaped)</td></tr>
      <tr><td><code>[^&hellip;]</code></td><td>negative character class (literal carets, hyphens, closing square brackets, and backslashes must be escaped)</td></tr>
      <tr><td><code>$\mlvar{char}_1$-$\mlvar{char}_2$</code></td><td>range of characters (inside character classes)</td></tr>
      <tr><td><code>$\mlvar{re}_1\mlvar{re}_2$</code></td><td>concatenation operation</td></tr>
      <tr><td><code>$\mlvar{re}_1$|$\mlvar{re}_2$</code></td><td>union (alternation) operation</td></tr>
      <tr><td><code>$\mlvar{re}_1$-$\mlvar{re}_2$</code></td><td>difference operation</td></tr>
      <tr><td><code>$\mlvar{re}$*</code></td><td>zero-or-more-times (Kleene star) operation</td></tr>
      <tr><td><code>$\mlvar{re}$+</code></td><td>one-or-more-times (Kleene plus) operation</td></tr>
      <tr><td><code>$\mlvar{re}$?</code></td><td>zero-or-one-time (optional) operation</td></tr>
      <tr><td>$\metavar{name}\Coloneq\mlvar{re}$</td><td>definition of a named regular expression</td></tr>
    </table>
    <p>Literal strings can contain the following escape sequences:</p>
    <table class="plain">
      <tr><th>Escape sequence</th><th>Meaning</th></tr>
      <tr><td><code>\\\\</code></td><td>the backslash</td></tr>
      <tr><td><code>\'</code></td><td>the single quote</td></tr>
      <tr><td><code>\"</code></td><td>the double quote</td></tr>
      <tr><td><code>\U{$\mlvar{hex}$}</code></td><td>the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$</td></tr>
    </table>
    <p>Character classes can contain the following escape sequences:</p>
    <table class="plain">
      <tr><th>Escape sequence</th><th>Meaning</th></tr>
      <tr><td><code>\\\\</code></td><td>the backslash</td></tr>
      <tr><td><code>\^</code></td><td>the caret</td></tr>
      <tr><td><code>\-</code></td><td>the hyphen</td></tr>
      <tr><td><code>\]</code></td><td>the closing square bracket</td></tr>
      <tr><td><code>\U{$\mlvar{hex}$}</code></td><td>the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$</td></tr>
      <tr><td><code>\C{$\mlvar{cat}$}</code></td><td>the Unicode characters whose general categories are $\mlvar{cat}$</td></tr>
    </table>
    <p>The zero-or-more-times, one-or-more-times, and zero-or-one-time operations have precedence over the concatenation operation and the concatenation operation has precedence over the union and difference operations. All operations are left associative. Parenthesis can be added to override those precedence and associativity rules.</p>
    <p>References to named regular expressions can be used wherever regular expressions can be used. References to named regular expressions denoting classes of characters can also be used inside character classes. Circular definitions are not allowed.</p>
    <p>Except for the parts referencing named regular expressions, regular expressions are typeset in a monospaced typeface. Spaces can be added freely outside literal strings and character classes without modifying the meaning of a regular expression.</p>
    <h4>Extended Backus-Naur Form (EBNF)</h4>
    <p>The parser and the syntax analyzer use a variant of the <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank">extended Backus-Naur form</a> (EBNF) notation to define various <a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank">context-free grammars</a>.</p>
    <p>The following table summarizes the syntax of the variant of the EBNF notation used in this document:</p>
    <table class="plain">
      <tr><th>Syntax</th><th>Meaning</th></tr>
      <tr><td>$\mlvar{lhs}$ $\Coloneq$ <code>$\mlvar{rhs}$</code></td><td>definition of a production rule</td></tr>
      <tr><td><code>$\metavar{nonterminal}$</code></td><td>nonterminal symbol</td></tr>
      <tr><td><code>terminal</code></td><td>terminal symbol</td></tr>
      <tr><td><code>$\epsilon$</code></td><td>empty sequence of symbols</td></tr>
      <tr><td><code>$\mlvar{rhs}_1$ | &hellip; | $\mlvar{rhs}_n$</code></td><td>union (alternation) operation</td></tr>
      <tr><td><code>$\mlvar{symbol}$*</code></td><td>zero-or-more-times (Kleene star) operation</td></tr>
      <tr><td><code>$\mlvar{symbol}$+</code></td><td>one-or-more-times (Kleene plus) operation</td></tr>
      <tr><td><code>$\mlvar{symbol}$?</code></td><td>zero-or-one-time (optional) operation</td></tr>
      <tr><td><code>{$\mlvar{rhs}$}</code></td><td>group</td></tr>
      <tr><td><code>?</code> &hellip; <code>?</code></td><td>special sequence</td></tr>
    </table>
    <p>A left-hand-side ($\mlvar{lhs}$) consists of a nonterminal symbol. A right-hand-side ($\mlvar{rhs}$) consists of a sequence of zero or more nonterminal and/or terminal symbols. A group can be used wherever a symbol can be used. A special sequence is a free-form text specifying a set of terminal symbols.</p>
    <h3>Tokenizer</h3>
    <p>The tokenizer converts an input sequence of Unicode characters into a sequence of tokens in two steps. During the first step, the tokenizer converts the input sequence of Unicode characters into a provisional sequence of tokens. During the second step, the tokenizer converts the provisional sequence of tokens into a final sequence of tokens.</p>
    <h4>Character Classes</h4>
    <p>Let us first define the following named regular expressions:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{valid-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>[\C{L}\C{M}\C{N}\C{P}\C{S}\C{Z}\U{0009}-\U{000D}\U{0085}\C{Cf}\C{Co}]</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{whitespace-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>[\U{0009}-\U{000D}\U{0020}\U{0085}\U{200E}\U{200F}\U{2028}\U{2029}]</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{syntax-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>['`,"()#]</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{xml-name-char}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>[a-z]</code></td>
      </tr>
    </table>
    <p>Each of those named regular expressions specifies a class of Unicode characters.</p>
    <p>The whitespace characters are the following characters:</p>
    <ul>
      <li>The horizontal tab control character (HT, $\unicode{0009}$).</li>
      <li>The line feed control character (LF, $\unicode{000A}$).</li>
      <li>The vertical tab control character (VT, $\unicode{000B}$).</li>
      <li>The form feed control character (FF, $\unicode{000C}$).</li>
      <li>The carriage return control character (CR, $\unicode{000D}$).</li>
      <li>The space ($\unicode{0020}$).</li>
      <li>The next line control character (NEL, $\unicode{0085}$).</li>
      <li>The left-to-right mark ($\unicode{200E}$).</li>
      <li>The right-to-left mark ($\unicode{200F}$).</li>
      <li>The line separator ($\unicode{2028}$).</li>
      <li>The paragraph separator ($\unicode{2029}$).</li>
    </ul>
    <p>In Linux and macOS operating systems, an end of line is represented by an LF character. In Windows operating systems, an end of line is represented by a CR character followed by an LF character.</p>
    <p>From the definition of $\metavar{valid-char}$, we can infer that the input sequence of Unicode characters must not contain any of the following characters and code points:</p>
    <ul>
      <li>The C0 and C1 control characters other than HT, LF, VT, FF, CR, and NEL.</li>
      <li>The surrogate code points.</li>
      <li>The noncharacters.</li>
      <li><span class="strike">The unassigned code points.</span></li>
    </ul>
    <p>The unassigned code points are actually allowed by the current version of the code.</p>
    <h4>Tokenization First Step</h4>
    <p>During the first step, the tokenizer converts the input sequence of Unicode characters into a provisional sequence of tokens of the following categories (patterns are regular expressions):</p>
    <dl>
      <dt><code>whitespace</code></dt>
      <dd>Pattern: <code>$\metavar{whitespace-char}$+</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>quote</code></dt>
      <dd>Pattern: <code>"'"</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>quasiquote</code></dt>
      <dd>Pattern: <code>'`'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>unquote</code></dt>
      <dd>Pattern: <code>','</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>unquote-splicing</code></dt>
      <dd>Pattern: <code>',@'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>string</code></dt>
      <dd>Pattern: <code>'"' (($\metavar{valid-char}$ - ["\\\\]) | ('\\\\' [\\\\"tnvfr]) | ('\\\\U{' [a-fA-F0-9]+ '}'))* '"'</code></dd>
      <dd>Value: The backslash plays the role of an escape character. The escape sequences are interpreted as specified in the table below. The value is an object of type <code>string</code> representing the sequence of UTF-16 code units encoding the sequence of Unicode characters delimited by the double quotes (after interpretation of the escape sequences).</dd>
      <dt><code>opening-parenthesis</code></dt>
      <dd>Pattern: <code>'('</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>closing-parenthesis</code></dt>
      <dd>Pattern: <code>')'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>hash-opening-parenthesis</code></dt>
      <dd>Pattern: <code>'#('</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>hash-plus</code></dt>
      <dd>Pattern: <code>'#+'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>hash-minus</code></dt>
      <dd>Pattern: <code>'#-'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>void</code></dt>
      <dd>Pattern: <code>'#v'</code></dd>
      <dd>Value: The value is the single object of type <code>void</code>.</dd>
      <dt><code>boolean</code></dt>
      <dd>Pattern: <code>'#t' | '#f'</code></dd>
      <dd>Value: If the lexeme matches <code>'#t'</code>, then the value is the single object of type <code>boolean</code> representing true. If the lexeme matches <code>'#f'</code>, then the value is the single object of type <code>boolean</code> representing false.</dd>
      <dt><code>hash-string</code></dt>
      <dd>Pattern: <code>'#' [0-9]* '"' (($\metavar{valid-char}$ - ["\\\\]) | ('\\\\' [\\\\"tnvfr]) | ('\\\\U{' [a-fA-F0-9]+ '}'))* '"'</code></dd>
      <dd>Value: The backslash plays the role of an escape character. The escape sequences are interpreted as specified in the table below. The value is the sequence of UTF-16 code units encoding the sequence of Unicode characters delimited by the double quotes (after interpretation of the escape sequences). An optional decimal numeral can be provided between the hash and the opening double quote.</dd>
      <dt><code>xml-start-tag</code></dt>
      <dd>Pattern: <code>'&lt;' $\metavar{xml-name-char}$+ '&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>xml-end-tag</code></dt>
      <dd>Pattern: <code>'&lt;/' $\metavar{xml-name-char}$+ '&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>xml-empty-element-tag</code></dt>
      <dd>Pattern: <code>'&lt;' $\metavar{xml-name-char}$+ '/&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>xml-comment</code></dt>
      <dd>Pattern: <code>'&lt;!--' (($\metavar{valid-char}$ - '-') | ('-' ($\metavar{valid-char}$ - '-')))* '--&gt;'</code></dd>
      <dd>Value: N/A</dd>
      <dt><code>proto-token</code></dt>
      <dd>Pattern: <code>(($\metavar{valid-char}$ - ($\metavar{whitespace-char}$ | $\metavar{syntax-char}$ | '\\\\')) | ('\\\\' [\\\\&lt;]) | ('\\\\U{' [a-fA-F0-9]+ '}'))+</code></dd>
      <dd>Value: The backslash plays the role of an escape character. The escape sequences are interpreted as specified in the table below. The value is the lexeme after interpretation of the escape sequences.</dd>
    </dl>
    <p>Escape sequences in lexemes associated with tokens of categories <code>string</code> and <code>hash-string</code> are interpreted as follows:</p>
    <table class="plain">
      <tr><th>Escape sequence</th><th>Meaning</th></tr>
      <tr><td><code>\\\\</code></td><td>the backslash</td></tr>
      <tr><td><code>\"</code></td><td>the double quote</td></tr>
      <tr><td><code>\t</code></td><td>the horizontal tab control character</td></tr>
      <tr><td><code>\n</code></td><td>the line feed control character</td></tr>
      <tr><td><code>\v</code></td><td>the vertical tab control character</td></tr>
      <tr><td><code>\f</code></td><td>the form feed control character</td></tr>
      <tr><td><code>\r</code></td><td>the carriage return control character</td></tr>
      <tr><td><code>\U{$\mlvar{hex}$}</code></td><td>the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$</td></tr>
    </table>
    <p>Escape sequences in lexemes associated with tokens of category <code>proto-token</code> are interpreted as follows:</p>
    <table class="plain">
      <tr><th>Escape sequence</th><th>Meaning</th></tr>
      <tr><td><code>\\\\</code></td><td>the backslash</td></tr>
      <tr><td><code>\&lt;</code></td><td>the less-than sign</td></tr>
      <tr><td><code>\U{$\mlvar{hex}$}</code></td><td>the Unicode character whose code point is represented by the hexadecimal numeral $\mlvar{hex}$</td></tr>
    </table>
    <p>Let $\mlvar{input}$ be the input sequence of Unicode characters. For any token $T$, let us denote by $\lex(T)$ the lexeme associated with $T$ and by $\pat(T)$ the pattern associated with $T$'s category. The tokenizer must find a sequence of tokens $\langle T_1,\ldots,T_n\rangle$ such that the following conditions are satisfied:</p>
    <ul>
      <li>$\lex(T_i)$ matches $\pat(T_i)$ for all $i$ from $1$ to $n$</li>
      <li>$\mlvar{input}=\lex(T_1)\ldots\lex(T_n)$</li>
    </ul>
    <p>Because the meaning of a program cannot be ambiguous, there cannot exist more than one sequence of tokens satisfying the previous conditions for any given input. As the following examples demonstrate, the patterns alone do not provide this guarantee:</p>
    <ul>
      <li>The input <code class="bg">foobar</code> has many competing interpretations, including the following two:
        <ul>
          <li><code class="bg">foo</code><sub><code>proto-token</code></sub> <code class="bg">bar</code><sub><code>proto-token</code></sub></li>
          <li><code class="bg">foobar</code><sub><code>proto-token</code></sub> (this is the intended interpretation)</li>
        </ul>
      </li>
      <li>The input <code class="bg">,@foo</code> has many competing interpretations, including the following two:
        <ul>
          <li><code class="bg">,</code><sub><code>unquote</code></sub> <code class="bg">@foo</code><sub><code>proto-token</code></sub></li>
          <li><code class="bg">,@</code><sub><code>unquote-splicing</code></sub> <code class="bg">foo</code><sub><code>proto-token</code></sub> (this is the intended interpretation)</li>
        </ul>
      </li>
      <li>The input <code class="bg">foo&lt;bar&gt;baz</code> has many competing interpretations, including the following two:
        <ul>
          <li><code class="bg">foo&lt;bar&gt;baz</code><sub><code>proto-token</code></sub></li>
          <li><code class="bg">foo</code><sub><code>proto-token</code></sub> <code class="bg">&lt;bar&gt;</code><sub><code>xml-start-tag</code></sub> <code class="bg">baz</code><sub><code>proto-token</code></sub>(this is the intended interpretation)</li>
        </ul>
      </li>
    </ul>
    <p>The tokenizer uses additional rules to resolve the ambiguities. Those additional rules are embedded into the algorithm provided below.</p>
    <p>EVLambda source code can only be found outside any XML element (this is the case in listener buffers and plain EVLambda source files) or directly inside a <code>chapter</code> or <code>section</code> XML element (this is the case in documented EVLambda source files). A context that cannot contain EVLambda source code is called a pure-xml context. When processing a pure-xml context, the tokenizer only recognizes tokens of the following categories: <code>whitespace</code> (any character data is treated as whitespace when processing a pure-xml context), <code>xml-start-tag</code>, <code>xml-end-tag</code>, <code>xml-empty-element-tag</code>, and <code>xml-comment</code>. The tokenizer uses a stack of XML element names to determine if it is processing a pure-xml context. The tokenizer is processing a pure-xml context when the stack is not empty and the name at the top of the stack is neither <code>chapter</code> nor <code>section</code>.</p>
    <p>Here is the algorithm  used by the tokenizer to convert the input sequence of Unicode characters into a provisional sequence of tokens (control normally flows from one step to the next and it is assumed that the stack of XML element names is initially empty):</p>
    <ul>
      <li>If the context is pure-xml and the next character is not a less-than sign, emit a token of category <code>whitespace</code> whose associated lexeme contains all the characters up to the end of the input or the first character that is a less-than sign (that character is not included in the lexeme).</li>
      <li>If the context is not pure-xml and the next character is a whitespace character, emit a token of category <code>whitespace</code> whose associated lexeme contains all the characters up to the end of the input or the first character that is not a whitespace character (that character is not included in the lexeme).</li>
      <li>If the end of the input has been reached, stop.</li>
      <li>If the next character is a single quote, emit a token of category <code>quote</code> and loop to the top.</li>
      <li>If the next character is a backquote, emit a token of category <code>quasiquote</code> and loop to the top.</li>
      <li>If the next character is a comma followed by an at sign, emit a token of category <code>unquote-splicing</code> and loop to the top.</li>
      <li>If the next character is a comma, emit a token of category <code>unquote</code> and loop to the top.</li>
      <li>If the next character is a double quote, emit a token of category <code>string</code> whose associated lexeme contains all the characters up to the first unescaped double quote (that character is included in the lexeme) and loop to the top. Fail if the lexeme contains an invalid escape sequence or the closing double quote is missing.</li>
      <li>If the next character is an opening parenthesis, emit a token of category <code>opening-parenthesis</code> and loop to the top.</li>
      <li>If the next character is a closing parenthesis, emit a token of category <code>closing-parenthesis</code> and loop to the top.</li>
      <li>If the next character is a hash followed by an opening parenthesis, emit a token of category <code>hash-opening-parenthesis</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a plus sign, emit a token of category <code>hash-plus</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a minus sign, emit a token of category <code>hash-minus</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a lowercase <code>v</code>, emit a token of category <code>void</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a lowercase <code>t</code>, emit a token of category <code>boolean</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a lowercase <code>f</code>, emit a token of category <code>boolean</code> and loop to the top.</li>
      <li>If the next character is a hash followed by a sequence of zero or more decimal digits followed by a double quote, emit a token of category <code>hash-string</code> whose associated lexeme contains all the characters up to the first unescaped double quote (that character is included in the lexeme) and loop to the top. Fail if the lexeme contains an invalid escape sequence or the closing double quote is missing.</li>
      <li>If the next character is a hash, fail.</li>
      <li>If the next character is a less-than sign that is the first character of an XML start tag, emit a token of category <code>xml-start-tag</code>, push the name of the start tag on the stack, and loop to the top.</li>
      <li>If the next character is a less-than sign that is the first character of an XML end tag, emit a token of category <code>xml-end-tag</code>, pop the top name off the stack, and loop to the top. Fail if the stack is empty or the top name does not match the name of the end tag.</li>
      <li>If the next character is a less-than sign that is the first character of an XML empty-element tag, emit a token of category <code>xml-empty-element-tag</code> and loop to the top.</li>
      <li>If the next character is a less-than sign that is the first character of an XML comment, emit a token of category <code>xml-comment</code> and loop to the top.</li>
      <li>If the context is pure-xml, fail.</li>
      <li>(The next character is neither a whitespace character, nor a syntax character, nor a less-than sign that is the first character of a piece of XML markup.) Emit a token of category <code>proto-token</code> whose associated lexeme contains all the characters up to the end of the input or the first character that is a whitespace character, a syntax character, or an unescaped less-than sign that is the first character of a piece of XML markup (that character is not included in the lexeme) and loop to the top. Fail if the lexeme contains an invalid escape sequence.</li>
    </ul>
    <h4>Tokenization Second Step</h4>
    <p>During the second step, the tokenizer converts the provisional sequence of tokens into a final sequence of tokens as follows:</p>
    <ul>
      <li>The tokens of category <code>whitespace</code> are discarded.</li>
      <li>Each token of category <code>hash-string</code> is processed as follows:
        <ul>
          <li>Case 1, the optional decimal numeral is not provided: Let $\langle\mlvar{code-unit}_0,\ldots,\mlvar{code-unit}_{n-1}\rangle$ be the value of the token of category <code>hash-string</code>. The token of category <code>hash-string</code> is replaced by a sequence of $n$ token(s) of category <code>character</code> such that the value of the $i$-th token of category <code>character</code> is an object of type <code>character</code> representing $\mlvar{code-unit}_i$.</li>
          <li>Case 2, the optional decimal numeral is provided: Let $\langle\mlvar{code-unit}_0,\ldots,\mlvar{code-unit}_{n-1}\rangle$ be the value of the token of category <code>hash-string</code> and $i$ be the nonnegative integer represented by the optional decimal numeral. If $i\lt n$, then the token of category <code>hash-string</code> is replaced by a token of category <code>character</code> whose value is an object of type <code>character</code> representing $\mlvar{code-unit}_i$. Otherwise, the tokenization fails.</li>
        </ul>
      </li>
      <li>Each token of category <code>proto-token</code> is replaced by a token of one of the following categories (patterns are regular expressions matched against the value of the token of category <code>proto-token</code>; the first pattern matching the value wins; tokenization fails if no pattern matches the value):
        <dl>
          <dt><code>dot</code></dt>
          <dd>Pattern: <code>'.'</code></dd>
          <dd>Value: N/A</dd>
          <dt><code>number</code></dt>
          <dd>Pattern: <code>('+' | '-')? [0-9]+ ('.' [0-9]+)?</code></dd>
          <dd>Value: The value is an object of type <code>number</code> representing the mathematical number of which the value matching the pattern is a decimal representation.</dd>
          <dt><code>keyword</code></dt>
          <dd>Pattern: <code>':' [^:]+</code></dd>
          <dd>Value: The value is the object of type <code>keyword</code> whose name is the value matching the pattern.</dd>
          <dt><code>variable</code></dt>
          <dd>Pattern: <code>[^:]+</code></dd>
          <dd>Value: The value is the object of type <code>variable</code> whose name is the value matching the pattern.</dd>
        </dl>
      </li>
      <li>The tokens of other categories are retained without modification.</li>
    </ul>
    <h4>Ninjas</h4>
    <p>This section illustrates the use of the hash-string construct.</p>
    <p>The Unicode character &ldquo;NINJA&rdquo; ($\unicode{1F977}$, high-surrogate $\unicode{D83E}$, low-surrogate $\unicode{DD77}$) represents a ninja with a nonrealistic skin tone:</p>
    <pre class="repl">&gt; '(#"&#x1F977;")<br>(#"\U{D83E}" #"\U{DD77}")<br><br>&gt; #0"&#x1F977;"<br>#"\U{D83E}"<br><br>&gt; #1"&#x1F977;"<br>#"\U{DD77}"</pre>
    <p>It is possible to obtain a ninja with a realistic skin tone by combining the Unicode character "NINJA" with one of the following skin-tone modifiers:</p>
    <table class="plain">
      <tr><th>Name</th><th>Code Point</th><th>High-Surrogate</th><th>Low-Surrogate</th><th>Sample</th></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-1-2</td><td>$\unicode{1F3FB}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFB}$</td><td>&#x1F3FB;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-3</td><td>$\unicode{1F3FC}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFC}$</td><td>&#x1F3FC;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-4</td><td>$\unicode{1F3FD}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFD}$</td><td>&#x1F3FD;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-5</td><td>$\unicode{1F3FE}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFE}$</td><td>&#x1F3FE;</td></tr>
      <tr><td>EMOJI MODIFIER FITZPATRICK TYPE-6</td><td>$\unicode{1F3FF}$</td><td>$\unicode{D83C}$</td><td>$\unicode{DFFF}$</td><td>&#x1F3FF;</td></tr>
    </table>
    <p>Here is the result of combining the Unicode character &ldquo;NINJA&rdquo; with the different skin-tone modifiers:</p>
    <pre class="repl">&gt; '(#"&#x1F977;&#x1F3FB;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFB}")<br><br>&gt; '(#"&#x1F977;&#x1F3FC;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFC}")<br><br>&gt; '(#"&#x1F977;&#x1F3FD;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFD}")<br><br>&gt; '(#"&#x1F977;&#x1F3FE;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFE}")<br><br>&gt; '(#"&#x1F977;&#x1F3FF;")<br>(#"\U{D83E}" #"\U{DD77}" #"\U{D83C}" #"\U{DFFF}")<br><br></pre>
    <h3>Parser</h3>
    <p>The parser uses a context-free grammar to convert the sequence of tokens produced by the tokenizer into a sequence of objects. The conversion is conceptually a two-step process. During the first step, the parser converts the sequence of tokens into a derivation tree. During the second step, the parser assigns a meaning to the derivation tree.</p>
    <p>The construction of the derivation tree is directed by the context-free grammar. Because the parser ignores the tokens' values and only takes into account the tokens' categories when constructing the derivation tree, the terminal symbols of the context-free grammar are the names of the token categories.</p>
    <p>The production rule describing the whole sequence of tokens produced by the tokenizer depends on the origin of the input sequence of characters.</p>
    <p>When the origin of the input sequence of characters is a listener buffer, the whole sequence of tokens is described by the following production rule:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{input}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{object}$</code></td>
      </tr>
    </table>
    <p>When the origin of the input sequence of characters is a plain EVLambda source file, the whole sequence of tokens is described by the following production rule:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{input}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{object}$*</code></td>
      </tr>
    </table>
    <p>When the origin of the input sequence of characters is a documented EVLambda source file, the whole sequence of tokens is described by the following production rule (the XML element is a chapter element):</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{input}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{xml-comment}$* $\metavar{xml-element}$ $\metavar{xml-comment}$*</code></td>
      </tr>
    </table>
    <p>The rest of the context-free grammar, which does not depend on the origin of the input sequence of characters, is defined as follows:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{xml-markup}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{xml-element}$ | $\metavar{xml-comment}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{xml-element}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>xml-start-tag $\metavar{xml-element-content}$* xml-end-tag | xml-empty-element-tag</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{xml-element-content}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{xml-markup}$ | $\metavar{object}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{xml-comment}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>xml-comment</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{object}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>void | boolean | number | character | string | keyword | variable | $\metavar{abbreviation}$ | $\metavar{list}$ | $\metavar{vector}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{abbreviation}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{quotation}$ | $\metavar{quasiquotation}$ | $\metavar{unquotation}$ | $\metavar{splicing-unquotation}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{quotation}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>quote $\metavar{xml-markup}$* $\metavar{object}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{quasiquotation}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>quasiquote $\metavar{xml-markup}$* $\metavar{object}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{unquotation}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>unquote $\metavar{xml-markup}$* $\metavar{object}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{splicing-unquotation}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>unquote-splicing $\metavar{xml-markup}$* $\metavar{object}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{proper-list}$ | $\metavar{dotted-list}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{proper-list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>left-parenthesis {$\metavar{xml-markup}$* $\metavar{object}$}* $\metavar{xml-markup}$* right-parenthesis</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{dotted-list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>left-parenthesis {$\metavar{xml-markup}$* $\metavar{object}$}+ $\metavar{xml-markup}$* dot $\metavar{xml-markup}$* $\metavar{object}$ $\metavar{xml-markup}$* right-parenthesis</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{vector}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>hash-left-parenthesis {$\metavar{xml-markup}$* $\metavar{object}$}* $\metavar{xml-markup}$* right-parenthesis</code></td>
      </tr>
    </table>
    <p>Let us denote by $\mathcal{M}$ the function assigning a meaning to a derivation tree. The function $\mathcal{M}$ is defined by specifying, for each production rule, how the meaning of the nonterminal symbol on the left-hand side is computed from (1) the meanings of the nonterminal symbols on the right-hand side and (2) the terminal symbols on the right-hand side. Here is the definition of the function $\mathcal{M}$ (pairs of angle brackets denote sequence formation and $\|$ denotes sequence concatenation):</p>
    <dl>
      <!-- input -->
      <dt>$\metavar{input}\Coloneq$ <code>$\metavar{object}$</code></dt>
      <dd>$\mathcal{M}(\metavar{input})=\langle\mathcal{M}(\metavar{object})\rangle$</dd>
      <dt>$\metavar{input}\Coloneq$ <code>$\metavarn{object}{1}\ldots\metavarn{object}{n\geq0}$</code></dt>
      <dd>$\mathcal{M}(\metavar{input})=\langle\mathcal{M}(\metavarn{object}{1}),\ldots,\mathcal{M}(\metavarn{object}{n})\rangle$</dd>
      <dt>$\metavar{input}\Coloneq$ <code>$\metavar{xml-comment}$* $\metavar{xml-element}$ $\metavar{xml-comment}$*</code></dt>
      <dd>$\mathcal{M}(\metavar{input})=\mathcal{M}(\metavar{xml-element})$</dd>
      <!-- xml-markup -->
      <dt>$\metavar{xml-markup}\Coloneq$ <code>$\metavar{xml-element}$</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-markup})=\mathcal{M}(\metavar{xml-element})$</dd>
      <dt>$\metavar{xml-markup}\Coloneq$ <code>$\metavar{xml-comment}$</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-markup})=\mathcal{M}(\metavar{xml-comment})$</dd>
      <!-- xml-element -->
      <dt>$\metavar{xml-element}\Coloneq$ <code>xml-start-tag $\metavarn{xml-element-content}{1}\ldots\metavarn{xml-element-content}{n\geq0}$ xml-end-tag</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-element})=\mathcal{M}(\metavarn{xml-element-content}{1})\|\cdots\|\mathcal{M}(\metavarn{xml-element-content}{n})$</dd>
      <dt>$\metavar{xml-element}\Coloneq$ <code>xml-empty-element-tag</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-element})=\langle\rangle$</dd>
      <!-- xml-element-content -->
      <dt>$\metavar{xml-element-content}\Coloneq$ <code>$\metavar{xml-markup}$</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-element-content})=\mathcal{M}(\metavar{xml-markup})$</dd>
      <dt>$\metavar{xml-element-content}\Coloneq$ <code>$\metavar{object}$</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-element-content})=\langle\mathcal{M}(\metavar{object})\rangle$</dd>
      <!-- xml-comment -->
      <dt>$\metavar{xml-comment}\Coloneq$ <code>xml-comment</code></dt>
      <dd>$\mathcal{M}(\metavar{xml-comment})=\langle\rangle$</dd>
      <!-- object -->
      <dt>$\metavar{object}\Coloneq$ <code>void</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>void</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>boolean</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>boolean</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>number</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>number</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>character</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>character</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>string</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>string</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>keyword</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>keyword</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>variable</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=$ the value of the token of category <code>variable</code></dd>
      <dt>$\metavar{object}\Coloneq$ <code>$\metavar{abbreviation}$</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=\mathcal{M}(\metavar{abbreviation})$</dd>
      <dt>$\metavar{object}\Coloneq$ <code>$\metavar{list}$</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=\mathcal{M}(\metavar{list})$</dd>
      <dt>$\metavar{object}\Coloneq$ <code>$\metavar{vector}$</code></dt>
      <dd>$\mathcal{M}(\metavar{object})=\mathcal{M}(\metavar{vector})$</dd>
      <!-- abbreviation -->
      <dt>$\metavar{abbreviation}\Coloneq$ <code>$\metavar{quotation}$</code></dt>
      <dd>$\mathcal{M}(\metavar{abbreviation})=\mathcal{M}(\metavar{quotation})$</dd>
      <dt>$\metavar{abbreviation}\Coloneq$ <code>$\metavar{quasiquotation}$</code></dt>
      <dd>$\mathcal{M}(\metavar{abbreviation})=\mathcal{M}(\metavar{quasiquotation})$</dd>
      <dt>$\metavar{abbreviation}\Coloneq$ <code>$\metavar{unquotation}$</code></dt>
      <dd>$\mathcal{M}(\metavar{abbreviation})=\mathcal{M}(\metavar{unquotation})$</dd>
      <dt>$\metavar{abbreviation}\Coloneq$ <code>$\metavar{splicing-unquotation}$</code></dt>
      <dd>$\mathcal{M}(\metavar{abbreviation})=\mathcal{M}(\metavar{splicing-unquotation})$</dd>
      <!-- quotation -->
      <dt>$\metavar{quotation}\Coloneq$ <code>quote $\metavar{object}$</code></dt>
      <dd>$\mathcal{M}(\metavar{quotation})=$ a cons whose car is the variable <code>quote</code> and whose cdr is a cons whose car is $\mathcal{M}(\metavar{object})$ and whose cdr is the empty list</dd>
      <!-- quasiquotation -->
      <dt>$\metavar{quasiquotation}\Coloneq$ <code>quasiquote $\metavar{object}$</code></dt>
      <dd>$\mathcal{M}(\metavar{quasiquotation})=$ a cons whose car is the variable <code>quasiquote</code> and whose cdr is a cons whose car is $\mathcal{M}(\metavar{object})$ and whose cdr is the empty list</dd>
      <!-- unquotation -->
      <dt>$\metavar{unquotation}\Coloneq$ <code>unquote $\metavar{object}$</code></dt>
      <dd>$\mathcal{M}(\metavar{unquotation})=$ a cons whose car is the variable <code>unquote</code> and whose cdr is a cons whose car is $\mathcal{M}(\metavar{object})$ and whose cdr is the empty list</dd>
      <!-- splicing-quotation -->
      <dt>$\metavar{splicing-unquotation}\Coloneq$ <code>unquote-splicing $\metavar{object}$</code></dt>
      <dd>$\mathcal{M}(\metavar{splicing-unquotation})=$ a cons whose car is the variable <code>unquote-splicing</code> and whose cdr is a cons whose car is $\mathcal{M}(\metavar{object})$ and whose cdr is the empty list</dd>
      <!-- list -->
      <dt>$\metavar{list}\Coloneq$ <code>$\metavar{proper-list}$</code></dt>
      <dd>$\mathcal{M}(\metavar{list})=\mathcal{M}(\metavar{proper-list})$</dd>
      <dt>$\metavar{list}\Coloneq$ <code>$\metavar{dotted-list}$</code></dt>
      <dd>$\mathcal{M}(\metavar{list})=\mathcal{M}(\metavar{dotted-list})$</dd>
      <!-- proper-list -->
      <dt>$\metavar{proper-list}\Coloneq$ <code>left-parenthesis right-parenthesis</code></dt>
      <dd>$\mathcal{M}(\metavar{proper-list})=$ the empty list</dd>
      <dt>$\metavar{proper-list}\Coloneq$ <code>left-parenthesis $\metavarn{object}{1}\ldots\metavarn{object}{n\geq1}$ right-parenthesis</code></dt>
      <dd>$\mathcal{M}(\metavar{proper-list})=$ the first cons of a chain of $n$ conses $\cons_1,\ldots,\cons_n$ such that the car of $\cons_i$ is $\mathcal{M}(\metavarn{object}{i})$, the cdr of $\cons_{i\lt n}$ is $\cons_{i+1}$, and the cdr of $\cons_n$ is the empty list</dd>
      <!-- dotted-list -->
      <dt>$\metavar{dotted-list}\Coloneq$ <code>left-parenthesis $\metavarn{object}{1}\ldots\metavarn{object}{n\geq1}$ dot $\metavarn{object}{n+1}$ right-parenthesis</code></dt>
      <dd>$\mathcal{M}(\metavar{dotted-list})=$ the first cons of a chain of $n$ conses $\cons_1,\ldots,\cons_n$ such that the car of $\cons_i$ is $\mathcal{M}(\metavarn{object}{i})$, the cdr of $\cons_{i\lt n}$ is $\cons_{i+1}$, and the cdr of $\cons_n$ is $\mathcal{M}(\metavarn{object}{n+1})$</dd>
      <!-- vector -->
      <dt>$\metavar{vector}\Coloneq$ <code>hash-left-parenthesis $\metavarn{object}{1}\ldots\metavarn{object}{n\geq0}$ right-parenthesis</code></dt>
      <dd>$\mathcal{M}(\metavar{vector})=$ a vector of $n$ elements $\mlvar{elem}_1,\ldots,\mlvar{elem}_n$ such that $\mlvar{elem}_i$ is $\mathcal{M}(\metavarn{object}{i})$</dd>
    </dl>
    <p>Note that the XML markup inside abbreviations, lists, and vectors cannot produce objects and has therefore been omitted from the definition of the function $\mathcal{M}$.</p>
    <h3>Pattern Language and Template Languages</h3>
    <p>The pattern language is a context-free language whose sentences are patterns meant to be matched against objects. The pattern language can be used to specify a set of objects $S$ as follows:</p>
    <ul>
      <li>Define a grammar $G$ whose sentences are also sentences of the pattern language.</li>
      <li>Declare that the objects belonging to $S$ are the objects matching at least one sentence of $G$.</li>
    </ul>
    <p>The language specified by a grammar such as $G$ is called a template language. Template languages will be used to specify the forms recognized by the syntax analyzer, to specify template macro calls, to specify data structures, &hellip;</p>
    <p>Here are the terminal symbols of the context-free grammar specifying the pattern language:</p>
    <ul>
      <li>The names of the types: $\object$, $\void$, $\boolean$, $\number$, $\character$, $\string$, $symbol$, $\keyword$, $\variable$, $\list$, $\emptylist$, $\cons$, $\vector$, $\function$, $\primitivefunction$, and $\closure$.</li>
      <li>The readable representations of the objects of type <code>void</code>, <code>boolean</code>, <code>number</code>, <code>character</code>, <code>string</code>, <code>keyword</code>, and <code>variable</code>.</li>
      <li>The opening parenthesis, the closing parenthesis, the dot, and the digraph consisting of a hash followed by an opening parenthesis.</li>
    </ul>
    <p>Here are the production rules of the context-free grammar specifying the pattern language:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{pattern}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{type}$ | $\metavar{void}$ | $\metavar{boolean}$ | $\metavar{number}$ | $\metavar{character}$ | $\metavar{string}$ | $\metavar{keyword}$ | $\metavar{variable}$ | $\metavar{list}$ | $\metavar{vector}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{type}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\object$ | $\void$ | $\boolean$ | $\number$ | $\character$ | $\string$ | $symbol$ | $\keyword$ | $\variable$ | $\list$ | $\emptylist$ | $\cons$ | $\vector$ | $\function$ | $\primitivefunction$ | $\closure$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{void}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>void</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{boolean}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>boolean</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{number}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>number</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{character}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>character</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{string}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>string</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{keyword}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>keyword</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{variable}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>?</code> any readable representation of an object of type <code>variable</code> <code>?</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{proper-list}$ | $\metavar{dotted-list}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{proper-list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>($\metavar{pattern}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{dotted-list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>($\metavar{pattern}$+ . $\metavar{pattern}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{vector}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>#($\metavar{pattern}$*)</code></td>
      </tr>
    </table>
    <p>The rules specifying if an object matches a pattern are the following:</p>
    <ul>
      <li>An object matches the name of a type if and only if the object is a member of the type.</li>
      <li>An object matches a readable representation if and only if the object is (or is <code>eql</code> to) the object denoted by the readable representation.</li>
      <li>An object matches the pattern <code>()</code> if and only if the object is the empty list.</li>
      <li>An object matches the pattern <code>($\metavarn{pattern}{1}\ldots\metavarn{pattern}{n\geq0}$)</code> if and only if the object is the first cons of a chain of $n$ conses $\cons_1,\ldots,\cons_n$ such that the car of $\cons_i$ matches $\metavarn{pattern}{i}$, the cdr of $\cons_{i\lt n}$ is $\cons_{i+1}$, and the cdr of $\cons_n$ is the empty list.</li>
      <li>An object matches the pattern <code>($\metavarn{pattern}{1}\ldots\metavarn{pattern}{n\geq1}$ . $\metavarn{pattern}{n+1}$)</code> if and only if the object is the first cons of a chain of $n$ conses $\cons_1,\ldots,\cons_n$ such that the car of $\cons_i$ matches $\metavarn{pattern}{i}$, the cdr of $\cons_{i\lt n}$ is $\cons_{i+1}$, and the cdr of $\cons_n$ matches $\metavarn{pattern}{n+1}$.</li>
      <li>An object matches the pattern <code>#($\metavarn{pattern}{1}\ldots\metavarn{pattern}{n\geq0}$)</code> if and only if the object is a vector of $n$ elements $\mlvar{elem}_1,\ldots,\mlvar{elem}_n$ such that $\mlvar{elem}_i$ matches $\metavarn{pattern}{i}$.</li>
    </ul>
    <p>By way of example, let us consider the template language specified by the following context-free grammar:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{association-list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>({($\metavar{key}$ . $\metavar{value}$)}*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{key}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\object$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{value}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\object$</code></td>
      </tr>
    </table>
    <p>The sentences of the example template language are the following:</p>
    <ul>
      <li><code>()</code></li>
      <li><code>(($\object$ . $\object$))</code></li>
      <li><code>(($\object$ . $\object$) ($\object$ . $\object$))</code></li>
      <li><code>(($\object$ . $\object$) ($\object$ . $\object$) ($\object$ . $\object$))</code></li>
      <li>&hellip;</li>
    </ul>
    <p>The objects specified by the example template language (= the objects matching at least one sentence of the example template language) are the proper lists of conses of arbitrary objects. As suggested by the names of the nonterminal symbols, the first object of each cons operates as a key, the second object of each cons operates as a value, and the proper list as a whole is called an association list.</p>
    <h3>Read-Time Conditionalization Facility</h3>
    <p>The purpose of the read-time conditionalization facility is to alter the flow of tokens according to some conditions. Because the facility is conceptually located between the tokenizer and the parser, its associated syntax does not belong to the context-free grammar used by the parser. It is however convenient to specify the syntax of a read-time conditional by the following production rule:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{read-time-conditional}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>{hash-plus | hash-minus} $\metavar{xml-markup}$* $\metavar{object}$ $\metavar{xml-markup}$* $\metavar{object}$</code></td>
      </tr>
    </table>
    <p>The first object is called the feature expression and the second object is called the conditionalized object.</p>
    <p>When the facility encounters a <code>hash-plus</code> or a <code>hash-minus</code> token, it instructs the parser to parse, hand over, and discard the feature expression. The feature expression is then evaluated by the facility according to the rules stated below. If the feature expression evaluates to true, then the facility ends its processing of the read-time conditional by instructing the parser to parse and retain the conditionalized object. (The net effect is the same as if only the tokens of the conditionalized object had existed.) If the feature expression evaluates to false, then the facility ends its processing of the read-time conditional by instructing the parser to parse and discard the conditionalized object. (The net effect is the same as if the tokens of the read-time conditional had not existed.)</p>
    <p>Feature expressions must belong to the set objects specified by the template language specified by the following context-free grammar:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{feature-expression}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\symbol$ | (not $\metavar{operand}$) | (and $\metavar{operand}$*) | (or $\metavar{operand}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{operand}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{feature-expression}$</code></td>
      </tr>
    </table>
    <p>Feature expressions are evaluated as follows:</p>
    <dl>
      <dt>$\metavar{feature-expression}\Coloneq$ <code>$\symbol$</code></dt>
      <dd>The feature expression evaluates to true if the symbol belongs to the value of the global variable <code>*features*</code> and to false otherwise.</dd>
      <dt>$\metavar{feature-expression}\Coloneq$ <code>(not $\metavar{operand}$)</code></dt>
      <dd>The feature expression evaluates to true if its operand evaluates to false and to false otherwise.</dd>
      <dt>$\metavar{feature-expression}\Coloneq$ <code>(and $\metavar{operand}$*)</code></dt>
      <dd>The feature expression evaluates to true if all its operands evaluate to true and to false otherwise.</dd>
      <dt>$\metavar{feature-expression}\Coloneq$ <code>(or $\metavar{operand}$*)</code></dt>
      <dd>The feature expression evaluates to false if all its operands evaluate to false and to true otherwise.</dd>
    </dl>
    <p>By way of example, let us consider the following sequence of characters:</p>
    <blockquote><code>(1 . #+foo 2 #-foo 3)</code></blockquote>
    <p>If the symbol <code>foo</code> belongs to the value of the global variable <code>*features*</code>, then the sequence of characters is parsed as the dotted list <code>(1 . 2)</code>. Otherwise, the sequence of characters is parsed as the dotted list <code>(1 . 3)</code>.</p>
    <h3>Syntax Analyzer</h3>
    <p>The forms recognized by the syntax analyzer are specified by the template language specified by the following context-free grammar:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{special-form}$ | $\metavar{macro-call}$ | $\metavar{plain-function-call}$ | $\metavar{self-evaluating-object}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{special-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{quote-form}$ | $\metavar{progn-form}$ | $\metavar{if-form}$ | $\metavar{lambda-abstraction}$ | $\metavar{variable-reference}$ | $\metavar{variable-assignment}$ | $\metavar{\_for-each-form}$ | $\metavar{\_catch-errors-form}$ | $\metavar{apply-form}$ | $\metavar{multiple-value-call-form}$ | $\metavar{multiple-value-apply-form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{quote-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(quote $\metavar{literal}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{literal}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\object$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{progn-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(progn $\metavar{serial-form}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{serial-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{if-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(if $\metavar{test-form}$ $\metavar{then-form}$ $\metavar{else-form}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{test-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{then-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{else-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{lambda-abstraction}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{\_vlambda-form}$ | $\metavar{\_mlambda-form}$ | $\metavar{\_flambda-form}$ | $\metavar{\_dlambda-form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{\_vlambda-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(_vlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{\_mlambda-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(_mlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{\_flambda-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(_flambda $\metavar{parameter-list}$ $\metavar{body}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{\_dlambda-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(_dlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{parameter-list}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\variable$ | ($\variable$*) | ($\variable$+ . $\variable$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{body}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{serial-form}$*</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{variable-reference}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\variable$ | $\metavar{vref-form}$ | $\metavar{fref-form}$ | $\metavar{dref-form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{vref-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(vref $\variable$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{fref-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(fref $\variable$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{dref-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(dref $\variable$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{variable-assignment}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{vset-form}$ | $\metavar{fset-form}$ | $\metavar{dset-form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{vset-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(vset! $\variable$ $\metavar{value-form}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{fset-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(fset! $\variable$ $\metavar{value-form}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{dset-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(dset! $\variable$ $\metavar{value-form}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{value-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{\_for-each-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(_for-each $\metavar{function-form}$ $\metavar{list-form}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{function-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{list-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{\_catch-errors-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(_catch-errors $\metavar{try-form}$)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{try-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{apply-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(apply $\metavar{operator-form}$ $\metavar{operand-form}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{multiple-value-call-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(multiple-value-call $\metavar{operator-form}$ $\metavar{operand-form}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{multiple-value-apply-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>(multiple-value-apply $\metavar{operator-form}$ $\metavar{operand-form}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{macro-call}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>($\metavar{macro-operator}$ $\metavar{macro-operand}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{macro-operator}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\variable$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{macro-operand}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\object$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{plain-function-call}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>($\metavar{operator-form}$ $\metavar{operand-form}$*)</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{operator-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{operand-form}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{form}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{self-evaluating-object}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\void$ | $\boolean$ | $\number$ | $\character$ | $\string$ | $\keyword$ | $\vector$ | $\primitivefunction$ | $\closure$</code></td>
      </tr>
    </table>
    <p>The names of the nonterminal symbols are the names that will be used throughout this document to name the forms and their components.</p>
    <p>The following production rules introduce additional terminology:</p>
    <table class="ebnf">
      <tr>
        <td class="lhs">$\metavar{special-operator}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>quote | progn | if | _vlambda | _mlambda | _flambda | _dlambda | vref | fref | dref | vset! | fset! | dset! | _for-each | _catch-errors | apply | multiple-value-call | multiple-value-apply</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{call}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{macro-call}$ | $\metavar{function-call}$</code></td>
      </tr>
      <tr>
        <td class="lhs">$\metavar{function-call}$</td>
        <td class="def">$\Coloneq$</td>
        <td class="rhs"><code>$\metavar{plain-function-call}$ | $\metavar{apply-form}$ | $\metavar{multiple-value-call-form}$ | $\metavar{multiple-value-apply-form}$</code></td>
      </tr>
    </table>
    <p>The variables <code>quasiquote</code>, <code>unquote</code>, and <code>unquote-splicing</code> are not special operators. The variable <code>quasiquote</code> is the name of a global macro and the variables <code>unquote</code> and <code>unquote-splicing</code> are variables having special meanings in the context of a call to the global macro <code>quasiquote</code>.</p>
    <p>A form consisting of a variable $\var$ is treated as an abbreviation. If it appears in operator position, then it is treated as an abbreviation for the special form <code>(fref $\var$)</code>. Otherwise, it is treated as an abbreviation for the special form <code>(vref $\var$)</code>.</p>
    <p>Classifying a form is the first step in evaluating a form. If the classification fails, then the evaluation fails.</p>
    <p>Some syntax analyzers classify forms without checking that the components that must be forms are actually forms. Syntax analyzers associated with interpreters usually function this way. With this kind of syntax analyzer, the components that must be forms are classified if and when they are evaluated.</p>
    <p>According to the template language, some objects can simultaneously be a special form, a macro call, and a plain function call. Additional rules are needed to disambiguate the situation.</p>
    <p>The following rules used by the syntax analyzer are not expressed by the template language:</p>
    <ul>
      <li>A list whose first element is a special operator is never classified as a call. Either the list is successfully classified as a special form or the classification fails.</li>
      <li>A list whose first element is a variable (other than a special operator) naming a macro according to the lookup rule used by <code>fref</code> is never classified as a plain function call. Either the list is successfully classified as a macro call or the classification fails.</li>
      <li>The variables of a parameter list must be distinct.</li>
    </ul>
    <h3>Documentation Generator</h3>
    <p>In this section, the character &#x21F0; marks the places where line breaks have been added to wrap long lines.</p>
    <p>Let us consider the following documented EVLambda source file:</p>
    <pre class="repl">&lt;chapter&gt;<br>&lt;title&gt;Recursive Functions&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;section&gt;<br>&lt;title&gt;Factorial Function&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>(fdef fact (n)<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  (if (= n 0)<br>      1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (* n (fact (- n 1))))) &lt;comment&gt;...eoll...&lt;/comment&gt;<br><br>(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))<br>&lt;/section&gt;<br>&lt;section&gt;<br>&lt;title&gt;Fibonacci Sequence&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>(fdef fib (n)<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  (if (= n 0)<br>      0 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (if (= n 1)<br>        1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>      (+ (fib (- n 1)) (fib (- n 2)))))) &lt;comment&gt;...eoll...&lt;/comment&gt;<br><br>(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))<br>&lt;/section&gt;<br>&lt;/chapter&gt;</pre>
    <p>The first step of the documentation generation process converts the documented EVLambda source file into the following XML document:</p>
    <pre class="repl">&lt;chapter&gt;<br>&lt;title&gt;Recursive Functions&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;section&gt;<br>&lt;title&gt;Factorial Function&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;toplevelcode&gt;&lt;blockcode&gt;(fdef fact (n)&#x21F0;<br>&lt;/blockcode&gt;&lt;indentation style="margin-left: 2ch;"&gt;&lt;blockcomment&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;&lt;/blockcomment&gt;&lt;/indentation&gt;&lt;blockcode&gt;<br>  (if (= n 0)<br>      1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (* n (fact (- n 1))))) &#x21F0;<br>&lt;comment&gt;...eoll...&lt;/comment&gt;&lt;/blockcode&gt;&lt;/toplevelcode&gt;<br><br>&lt;toplevelcode&gt;&lt;blockcode&gt;(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))&lt;/blockcode&gt;&lt;/toplevelcode&gt;<br>&lt;/section&gt;<br>&lt;section&gt;<br>&lt;title&gt;Fibonacci Sequence&lt;/title&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;para&gt;...para...&lt;/para&gt;<br>&lt;toplevelcode&gt;&lt;blockcode&gt;(fdef fib (n)&#x21F0;<br>&lt;/blockcode&gt;&lt;indentation style="margin-left: 2ch;"&gt;&lt;blockcomment&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;<br>  &lt;para&gt;...block...&lt;/para&gt;&lt;/blockcomment&gt;&lt;/indentation&gt;&lt;blockcode&gt;<br>  (if (= n 0)<br>      0 &lt;comment&gt;...eol...&lt;/comment&gt;<br>    (if (= n 1)<br>        1 &lt;comment&gt;...eol...&lt;/comment&gt;<br>      (+ (fib (- n 1)) (fib (- n 2)))))) &#x21F0;<br>&lt;comment&gt;...eoll...&lt;/comment&gt;&lt;/blockcode&gt;&lt;/toplevelcode&gt;<br><br>&lt;toplevelcode&gt;&lt;blockcode&gt;(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))&lt;/blockcode&gt;&lt;/toplevelcode&gt;<br>&lt;/section&gt;<br>&lt;/chapter&gt;</pre>
    <p>Here are a few remarks about the XML document:</p>
    <ul>
      <li>The XML document is well-formed. (In this case, the documented EVLambda source file was already well-formed because the code does not contain any &lt; or &amp; character.)</li>
      <li>Top-level forms are delimited by <code>toplevelcode</code> elements.</li>
      <li>Consecutive top-level forms that are not separated by at least one blank line are lumped into the same <code>toplevelcode</code> element.</li>
      <li>The content of a <code>toplevelcode</code> element is segmented into a sequence of <code>blockcode</code> elements, which contain code and end-of-line/end-of-last-line comments, and <code>blockcomment</code> elements, which contain block comments.</li>
      <li>Each <code>blockcomment</code> element is wrapped into an <code>indentation</code> element that specifies its indentation through the CSS property <code>margin-left</code>.</li>
    </ul>
    <p>The second step of the documentation generation process converts the XML document into the following HTML document:</p>
    <pre class="repl">&lt;html&gt;<br>  &lt;head&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;h1&gt;Recursive Functions&lt;/h1&gt;<br>    &lt;p&gt;...para...&lt;/p&gt;<br>    &lt;p&gt;...para...&lt;/p&gt;<br>    &lt;h2&gt;Factorial Function&lt;/h2&gt;<br>    &lt;p&gt;...para...&lt;/p&gt;<br>    &lt;p&gt;...para...&lt;/p&gt;<br>    &lt;pre class="blockcode"&gt;(fdef fact (n)&lt;/pre&gt;<br>    &lt;div class="indentation" style="margin-left: 2ch;"&gt;<br>      &lt;div class="blockcomment"&gt;<br>        &lt;p&gt;...block...&lt;/p&gt;<br>        &lt;p&gt;...block...&lt;/p&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;pre class="blockcode"&gt;<br>  (if (= n 0)<br>      1 &lt;span class="eolcomment"&gt;...eol...&lt;/span&gt;<br>    (* n (fact (- n 1))))) &#x21F0;<br>&lt;span class="eolcomment"&gt;...eoll...&lt;/span&gt;&lt;/pre&gt;<br>    &lt;pre class="blockcode"&gt;(test 1 (fact 0))<br>(test 120 (fact 5))<br>(test 3628800 (fact 10))&lt;/pre&gt;<br>    &lt;h2&gt;Fibonacci Sequence&lt;/h2&gt;<br>    &lt;p&gt;...para...&lt;/p&gt;<br>    &lt;p&gt;...para...&lt;/p&gt;<br>    &lt;pre class="blockcode"&gt;(fdef fib (n)&lt;/pre&gt;<br>    &lt;div class="indentation" style="margin-left: 2ch;"&gt;<br>      &lt;div class="blockcomment"&gt;<br>        &lt;p&gt;...block...&lt;/p&gt;<br>        &lt;p&gt;...block...&lt;/p&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;pre class="blockcode"&gt;<br>  (if (= n 0)<br>      0 &lt;span class="eolcomment"&gt;...eol...&lt;/span&gt;<br>    (if (= n 1)<br>        1 &lt;span class="eolcomment"&gt;...eol...&lt;/span&gt;<br>      (+ (fib (- n 1)) (fib (- n 2)))))) &#x21F0;<br>&lt;span class="eolcomment"&gt;...eoll...&lt;/span&gt;&lt;/pre&gt;<br>    &lt;pre class="blockcode"&gt;(test 0 (fib 0))<br>(test 5 (fib 5))<br>(test 55 (fib 10))&lt;/pre&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre>
    <h2>Semantics</h2>
    <h3>Primitive Data Types and Primitive Functions</h3>
    <p>This section inventories all the primitive data types and all the primitive functions.</p>
    <p>For each primitive function, a template function call and a description of the primitive function's behavior are provided.</p>
    <p>In template function calls, argument names imply the following type restrictions:</p>
    <ul>
      <li>Arguments named $\object$, with or without a subscript, can be of any type.</li>
      <li>Arguments named $\number$, with or without a subscript, must be of type <code>number</code>.</li>
      <li>Arguments named $\string$, with or without a subscript, must be of type <code>string</code>.</li>
      <li>Arguments named $\variable$, with or without a subscript, must be of type <code>variable</code>.</li>
      <li>Arguments named $\cons$, with or without a subscript, must be of type <code>cons</code>.</li>
    </ul>
    <p>If any argument is not of its required type, then the invocation of the primitive function completes abnormally.</p>
    <h4>Primitive Data Types</h4>
    <p>Here is a tree-view representation of the hierarchy of primitive data types:</p>
    <pre>object<br>  |-void<br>  |-boolean<br>  |-number<br>  |-character<br>  |-string<br>  |-symbol<br>  |   |-keyword<br>  |   |-variable<br>  |-list<br>  |   |-empty-list<br>  |   |-cons<br>  |-vector<br>  |-function<br>  |   |-primitive-function<br>  |   |-closure</pre>
    <h4>Primitive Data Type <code>object</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(object? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>object</code> (which is always the case) and <code>#f</code> otherwise.</dd>
      <dt><code>(eq? $\object_1$ $\object_2$)</code></dt>
      <dd>The primitive function is an equality predicate. It returns <code>#t</code> if and only if the two objects are one and the same. In other words, it returns <code>#t</code> if and only if the two objects have the same address in the heap.</dd>
      <dt><code>(eql? $\object_1$ $\object_2$)</code></dt>
      <dd>The primitive function is an equality predicate. If both objects are of type <code>number</code>, then it returns <code>#t</code> if and only if the two objects represent the same mathematical number. Otherwise, if both objects are of type <code>character</code>, then it returns <code>#t</code> if and only if the two objects represent the same UTF-$16$ code unit. Otherwise, if both objects are of type <code>string</code>, then it returns <code>#t</code> if and only if the two objects represent the same indexed sequence of UTF-$16$ code units. Otherwise, it returns <code>#t</code> if and only if the two objects are <code>eq?</code>.</dd>
    </dl>
    <h4>Primitive Data Type <code>void</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(void? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>void</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>boolean</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(boolean? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>boolean</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>number</code> and Related Primitive Functions</h4>
    <p>Objects of type <code>number</code> represent mathematical numbers using the floating-point format <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank">IEEE 754 binary 64</a>.
    <dl>
      <dt><code>(number? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>number</code> and <code>#f</code> otherwise.</dd>
      <dt><code>(_+ $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns the sum $\number_1+\number_2$.</dd>
      <dt><code>(_- $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns the difference $\number_1-\number_2$.</dd>
      <dt><code>(_* $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns the product $\number_1\times\number_2$.</dd>
      <dt><code>(_/ $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns the quotient $\number_1\div\number_2$.</dd>
      <dt><code>(% $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns the remainder of the division of $\number_1$ by $\number_2$ when the quotient is forced to be an integer.</dd>
      <dt><code>(= $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\number_1$ and $\number_2$ are numerically equal and <code>#f</code> otherwise.</dd>
      <dt><code>(/= $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\number_1$ and $\number_2$ are numerically different and <code>#f</code> otherwise.</dd>
      <dt><code>(&lt; $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\number_1$ is numerically less than $\number_2$ and <code>#f</code> otherwise.</dd>
      <dt><code>(&lt;= $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\number_1$ is numerically less than or equal to $\number_2$ and <code>#f</code> otherwise.</dd>
      <dt><code>(&gt; $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\number_1$ is numerically greater than $\number_2$ and <code>#f</code> otherwise.</dd>
      <dt><code>(&gt;= $\number_1$ $\number_2$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\number_1$ is numerically greater than or equal to $\number_2$ and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>character</code> and Related Primitive Functions</h4>
    <p>Contrary to what was said in the user manual, an object of type <code>character</code> represents a UTF-$16$ code unit (instead of a Unicode character).</p>
    <dl>
      <dt><code>(character? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>character</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>string</code> and Related Primitive Functions</h4>
    <p>Contrary to what was said in the user manual, an object of type <code>string</code> represents an indexed sequence of UTF-$16$ code units (instead of an indexed sequence of Unicode characters).</p>
    <dl>
      <dt><code>(string? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>string</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>symbol</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(symbol? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>symbol</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>keyword</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(keyword? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>keyword</code> and <code>#f</code> otherwise.</dd>
      <dt><code>(make-keyword? $\string$)</code></dt>
      <dd>The primitive function returns a new keyword whose name is $\string$. The keyword is not interned.</dd>
    </dl>
    <h4>Primitive Data Type <code>variable</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(variable? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>variable</code> and <code>#f</code> otherwise.</dd>
      <dt><code>(make-variable $\string$)</code></dt>
      <dd>The primitive function returns a new variable whose name is $\string$. The variable is not interned.</dd>
      <dt><code>(variable-value $\variable$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the value namespace of the global environment, then the primitive function returns the value of that binding. Otherwise, the primitive function returns <code>#v</code>.</dd>
      <dt><code>(variable-set-value! $\variable$ $\object$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the value namespace of the global environment, then the primitive function replaces the value of that binding by $\object$. Otherwise, the primitive function adds to the value namespace of the global environment a new binding between $\variable$ and $\object$. In both cases, the primitive function returns $\object$.</dd>
      <dt><code>(variable-value-bound? $\variable$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the value namespace of the global environment, then the primitive function returns <code>#t</code>. Otherwise, the primitive function returns <code>#f</code>.</dd>
      <dt><code>(variable-unbind-value! $\variable$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the value namespace of the global environment, then that binding is deleted and the primitive function returns <code>#v</code>. Otherwise, the primitive function simply returns <code>#v</code>.</dd>
      <dt><code>(variable-function $\variable$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the function namespace of the global environment, then the primitive function returns the value of that binding. Otherwise, the primitive function returns <code>#v</code>.</dd>
      <dt><code>(variable-set-function! $\variable$ $\object$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the function namespace of the global environment, then the primitive function replaces the value of that binding by $\object$. Otherwise, the primitive function adds to the function namespace of the global environment a new binding between $\variable$ and $\object$. In both cases, the primitive function returns $\object$.</dd>
      <dt><code>(variable-function-bound? $\variable$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the function namespace of the global environment, then the primitive function returns <code>#t</code>. Otherwise, the primitive function returns <code>#f</code>.</dd>
      <dt><code>(variable-unbind-function! $\variable$)</code></dt>
      <dd>If there exists a binding for $\variable$ in the function namespace of the global environment, then that binding is deleted and the primitive function returns <code>#v</code>. Otherwise, the primitive function simply returns <code>#v</code>.</dd>
    </dl>
    <h4>Primitive Data Type <code>list</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(list? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>list</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>empty-list</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(empty-list? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>empty-list</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>cons</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(cons? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>cons</code> and <code>#f</code> otherwise.</dd>
      <dt><code>(cons $\object_1$ $\object_2$)</code></dt>
      <dd>The primitive function returns a new cons whose first element is $\object_1$ and whose second element is $\object_2$.</dd>
      <dt><code>(car $\cons$)</code></dt>
      <dd>The primitive function returns the first element of $\cons$.</dd>
      <dt><code>(set-car! $\cons$ $\object$)</code></dt>
      <dd>The primitive function replaces the first element of $\cons$ by $\object$ and returns $\object$.</dd>
      <dt><code>(cdr $\cons$)</code></dt>
      <dd>The primitive function returns the second element of $\cons$</dd>
      <dt><code>(set-cdr! $\cons$ $\object$)</code></dt>
      <dd>The primitive function replaces the second element of $\cons$ by $\object$ and returns $\object$.</dd>
    </dl>
    <h4>Primitive Data Type <code>vector</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(vector? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>vector</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>function</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(function? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>function</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>primitive-function</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(primitive-function? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>primitive-function</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Primitive Data Type <code>closure</code> and Related Primitive Functions</h4>
    <dl>
      <dt><code>(closure? $\object$)</code></dt>
      <dd>The primitive function returns <code>#t</code> if $\object$ is of type <code>closure</code> and <code>#f</code> otherwise.</dd>
    </dl>
    <h4>Miscellaneous Primitive Functions</h4>
    <dl>
      <dt><code>(values $\object_1\ldots\object_n$)</code></dt>
      <dd>The primitive function converts its arguments into values: when invoked on the arguments $\object_1,\ldots,\object_n$, the primitive function returns the values $\object_1,\ldots,\object_n$.</dd>
      <dt><code>(error $\string$)</code></dt>
      <dd>The invocation of the primitive function always completes abnormally.</dd>
      <dt><code>(now)</code></dt>
      <dd>The primitive function returns the number of milliseconds elapsed since 1970-01-01 00:00:00.000 UTC.</dd>
    </dl>
  </body>
</html>
