<!doctype html>
<!-- SPDX-FileCopyrightText: Copyright (c) 2024-2025 Raphaël Van Dyck -->
<!-- SPDX-License-Identifier: BSD-3-Clause -->
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="___cssURL___"/>
    <script src="___jsURL___"></script>
    <script>const windowId = ___windowId___;</script>
  </head>
  <body>
    <h1>User Manual</h1>
    <h2>Project</h2>
    <p>The goal of the EVLambda project is to write from scratch a custom <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" target="_blank">Lisp</a> dialect and to use the resulting programming language to explore various science topics. Along the way, the programming language will be fine-tuned and complemented by libraries also written from scratch whenever possible.</p>
    <p>Please note that providing a stable programming language useful outside of the project is a non-goal. Backward compatibility will not be a priority and the decision to include a feature or an optimization will be based primarily on its usefulness to the project.</p>
    <h2 id="programming-language">Programming Language</h2>
    <p>This section provides an overview of the programming language. Some of the concepts introduced in this section will be illustrated in the section <a href="#listener-buffers">Listener Buffers</a>. An introduction to writing programs can be found in the tutorial. A detailed account of the programming language can be found in the reference manual.</p>
    <p>The programming language, which is called EVLambda like the project, is heavily inspired by the programming languages <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)" target="_blank">Scheme</a> and <a href="https://en.wikipedia.org/wiki/Common_Lisp" target="_blank">Common Lisp</a>. The bibliography contains many references covering and/or using those two programming languages.</p>
    <p>In EVLambda, there is no difference of nature between code and data. Both code and data are represented by objects and it is the context of its occurrence that determines if an object must be treated as code or as data. The word &ldquo;object&rdquo; is used here in the broad sense of data structure without any reference to object-oriented programming.</p>
    <p>As we will see later in this section, objects are patterns of bits inside the computer's memory. To facilitate communicating about objects, reading and writing code and data, etc., objects have associated sequences of characters that can be used to represent them.</p>
    <p>Most objects have at least one readable representation. A readable representation of an object is a sequence of characters that can be used to represent the object in input operations. The reader is the component of the programming language responsible for converting a readable representation into the corresponding object.</p>
    <p>All objects have exactly one printable representation. The printable representation of an object is a sequence of characters that can be used to represent the object in output operations. When an object has exactly one readable representation, its printable representation is identical to its readable representation. When an object has more than one readable representation, its printable representation is identical to one of its readable representations chosen to be the standard way to represent the object. When an object has no readable representations, its printable representation is a sequence of characters revealing its type. The printer is the component of the programming language responsible for converting an object into its printable representation.</p>
    <p>Objects are organized into classes called types and types are organized into a hierarchy of types. The type at the top of the hierarchy is called the root type. The types at the bottom of the hierarchy are called the leaf types. Any object belongs to exactly one leaf type. If type $A$ is located below type $B$ in the hierarchy, then type $A$ is called a subtype of type $B$ and any object that belongs to type $A$ also belongs to type $B$. The term &ldquo;data type&rdquo; is sometimes used in place of the term &ldquo;type&rdquo; even though a (data) type is a class of objects and an object can be a piece of code or a piece of data.</p>
    <p>Here is a tree-view representation of the hierarchy of types:</p>
    <pre>object<br>  |-void<br>  |-boolean<br>  |-number<br>  |-character<br>  |-string<br>  |-symbol<br>  |   |-keyword<br>  |   |-variable<br>  |-list<br>  |   |-empty-list<br>  |   |-cons<br>  |-vector<br>  |-function<br>  |   |-primitive-function<br>  |   |-closure</pre>
    <p>Here is a brief description of the leaf types (readable and printable representations have a gray background):</p>
    <dl>
      <dt><code>void</code></dt>
      <dd>There is exactly one object of type <code>void</code>. Its readable representation is <code class="bg">#v</code> and its purpose is to represent missing or undefined objects.</dd>
      <dt><code>boolean</code></dt>
      <dd>Booleans represent truth values. There are exactly two objects of type <code>boolean</code>: <code class="bg">#t</code> (representing true) and <code class="bg">#f</code> (representing false).</dd>
      <dt><code>number</code></dt>
      <dd>Numbers represent mathematical numbers: <code class="bg">123</code>, <code class="bg">-123</code>, <code class="bg">123.456</code>, <code class="bg">-123.456</code>, &hellip; The representation of a mathematical number by an object of type <code>number</code> can be exact or approximate.</dd>
      <dt><code>character</code></dt>
      <dd>Characters represent Unicode characters: <code class="bg">#"a"</code>, <code class="bg">#"b"</code>, <code class="bg">#"c"</code>, <code class="bg">#"你"</code>, <code class="bg">#"好"</code>, &hellip; Most of the characters used in the world have a corresponding <a href="https://home.unicode.org/" target="_blank">Unicode</a> character.</dd>
      <dt><code>string</code></dt>
      <dd>Strings represent indexed sequences of Unicode characters: <code class="bg">"abc"</code>, <code class="bg">"你好"</code>, &hellip;</dd>
      <dt><code>keyword</code></dt>
      <dd>Keywords can, among other uses, represent named values: <code class="bg">:red</code>, <code class="bg">:green</code>, <code class="bg">:blue</code>, &hellip;</dd>
      <dt><code>variable</code></dt>
      <dd>Variables are primarily used to name objects and various other entities. For example, the names of the types are variables: <code class="bg">object</code>, <code class="bg">void</code>, &hellip;</dd>
      <dt><code>empty-list</code></dt>
      <dd>There is exactly one object of type <code>empty-list</code>. Its readable representation is <code class="bg">()</code> and its purpose is to represent empty lists of objects.</dd>
      <dt><code>cons</code></dt>
      <dd>A cons is an ordered pair of objects. The first element is called the car of the cons and the second element is called the cdr of the cons. Conses are the building blocks of many data structures. In particular, conses can be chained together to represent nonempty lists of objects. A nonempty list of objects is represented by a cons whose car is the first element of the list and whose cdr is the sublist of the list obtained by omitting its first element. For example, the list <code class="bg">(1 2 3)</code> is represented by a chain of three conses: a first cons whose car is the number <code class="bg">1</code> and whose cdr is the second cons, a second cons whose car is the number <code class="bg">2</code> and whose cdr is the third cons, and a third cons whose car is the number <code class="bg">3</code> and whose cdr is the empty list.</dd>
      <dt><code>vector</code></dt>
      <dd>Vectors represent indexed sequences of objects: <code class="bg">#()</code>, <code class="bg">#(1 2 3)</code>, &hellip;</dd>
      <dt><code>primitive-function</code></dt>
      <dd>Primitive functions are input/output mappings implemented in a programming language other than EVLambda. Primitive functions have no readable representations and their printable representation is <code class="bg">#&lt;primitive-function&gt;</code>.</dd>
      <dt><code>closure</code></dt>
      <dd>Closures are input/output mappings implemented in EVLambda. Some closures are tagged as being a macro. Macros are code to code mappings used to create new language constructs. Closures have no readable representations and their printable representation is <code class="bg">#&lt;closure&gt;</code>.</dd>
    </dl>
    <p>Each symbol has an associated sequence of characters (called the name of the symbol) that serves as its readable representation. If the name of a symbol starts with a colon, then the symbol is a keyword. Otherwise, the symbol is a variable. The reader always converts the same name into the same symbol. To that end, the reader maintains two mappings from names to symbols called packages: one package mapping the names of the previously encountered variables to the corresponding variables and one package mapping the names of the previously encountered keywords to the corresponding keywords.</p>
    <p>The printable representation of a list consists of a left parenthesis followed by the printable representations of the elements of the list separated by a single space followed by a right parenthesis. The printable representation of a list is just one of its infinitely many readable representations. In particular, other readable representations can be obtained by using sequences of at least one whitespace character instead of single spaces to separate the elements of the list.</p>
    <p>Although a macro is technically a function (because a macro is an object of type <code>closure</code> and type <code>closure</code> is a subtype of type <code>function</code>), the word &ldquo;function&rdquo; is often used to denote specifically a function other than a macro (that is, a primitive function or a closure not tagged as being a macro).</p>
    <p>Variables name objects through the use of namespaces, bindings, environments, and lookup rules:</p>
    <ul>
      <li>Namespaces are a general mechanism allowing the same name to have different meanings in different contexts. EVLambda uses namespaces to allow the same variable to name two objects: one object that is used by default in contexts requiring an object of type <code>function</code> and another object that is used by default in all other contexts.</li>
      <li>A binding is an association between a variable (called the name of the binding) and an object (called the value of the binding). Each binding is labeled with a namespace name: &ldquo;value&rdquo; or &ldquo;function&rdquo;. By default, bindings labeled with the namespace name &ldquo;function&rdquo; are used in contexts requiring an object of type <code>function</code> and bindings labeled with the namespace name &ldquo;value&rdquo; are used in all other contexts. Although the constraint is not enforced by the programming language, the value of a binding labeled with the namespace name &ldquo;function&rdquo; should be of type <code>function</code>.</li>
      <li>An environment is a set of bindings. By grouping together the bindings labeled with the same namespace name, an environment can be partitioned into two possibly empty subsets called the value namespace and the function namespace. The purpose of a namespace is to implement a nonambiguous partial mapping from variables to objects. A consequence of the nonambiguity requirement is that a namespace cannot contain more than one binding for the same variable.</li>
      <li>Lookup rules are needed because, as we will see later in this section, three environments are always active at any given time. The lookup rules determine which environments to consult and in which order.</li>
    </ul>
    <p>A variable that is associated with an object through a binding belonging to namespace $X$ of environment $Y$ is said to be bound to the object in namespace $X$ of environment $Y$. A variable that is not associated with an object through a binding belonging to namespace $X$ of environment $Y$ is said to be unbound in namespace $X$ of environment $Y$.</p>
    <p>Objects, bindings, and environments are represented by nonoverlapping patterns of bits located inside a region of the computer's memory called the heap. Each object, binding, or environment is uniquely identified by the address of the pattern of bits that represents it. Like objects, bindings, and environments, addresses are also represented by patterns of bits. A reference to an object, binding, or environment is an instance of the pattern of bits that represents the address of the pattern of bits that represents the object, binding, or environment. By abuse of language, we often confuse a reference to an object, binding, or environment with the object, binding, or environment being referenced.</p>
    <p>The pattern of bits representing an object has two parts: one part specifying the type of the object and one part specifying which member of the type the object is.</p>
    <p>An object, binding, or environment references another object, binding, or environment by embedding into its representation a reference to that other object, binding, or environment:</p>
    <ul>
      <li>A cons references two objects of arbitrary types (the car and the cdr of the cons).</li>
      <li>A vector of length $n$ references $n$ objects of arbitrary types (the elements of the vector).</li>
      <li>A closure references a lambda abstraction (a list specifying an input/output mapping) and an environment.</li>
      <li>A binding references a variable (the name of the binding) and an object of arbitrary type (the value of the binding).</li>
      <li>An environment references its bindings.</li>
    </ul>
    <p>The references embedded into the representation of an object, binding, or environment can be thought of as occupying memory locations denoted by the object, binding, or environment. For example, a cons can be thought of as denoting two memory locations: one containing a reference to the car of the cons and one containing a reference to the cdr of the cons. By abuse of language, we often say that a memory location contains an object, binding, or environment when in reality the memory location contains a reference to the object, binding, or environment.</p>
    <p>Multiple objects, bindings, and environments can reference a common object, binding, or environment, leading to the sharing of the common object, binding, or environment. An object, binding, or environment can reference itself directly ($X\rightarrow X$) or indirectly ($X\rightarrow Y\rightarrow\cdots\rightarrow X$), leading to the existence of a cycle.</p>
    <p>Objects of type <code>void</code>, <code>boolean</code>, <code>keyword</code>, <code>symbol</code>, and <code>empty-list</code> have the following uniqueness properties:</p>
    <ul>
      <li>There exists in the heap exactly one object of type <code>void</code>.</li>
      <li>There exists in the heap exactly one object of type <code>boolean</code> representing true.</li>
      <li>There exists in the heap exactly one object of type <code>boolean</code> representing false.</li>
      <li>There cannot exist in the heap more than one object of type <code>keyword</code> with the same name. (This property is enforced by the reader.)</li>
      <li>There cannot exist in the heap more than one object of type <code>variable</code> with the same name. (This property is enforced by the reader.)</li>
      <li>There exists in the heap exactly one object of type <code>empty-list</code>.</li>
    </ul>
    <p>Objects of type <code>integer</code>, <code>character</code>, and <code>string</code> do not have similar uniqueness properties:</p>
    <ul>
      <li>There can exist in the heap more than one object of type <code>number</code> representing the same mathematical number.</li>
      <li>There can exist in the heap more than one object of type <code>character</code> representing the same Unicode character.</li>
      <li>There can exist in the heap more than one object of type <code>string</code> representing the same indexed sequence of Unicode characters.</li>
    </ul>
    <p>Objects of type <code>void</code>, <code>boolean</code>, <code>number</code>, <code>character</code>, <code>string</code>, <code>keyword</code>, <code>symbol</code>, <code>empty-list</code>, <code>primitive-function</code>, and <code>closure</code> are immutable and cannot be altered. Objects of type <code>cons</code> and <code>vector</code>, bindings, and environments are mutable and can be altered in the following ways:</p>
    <ul>
      <li>The car and the cdr of a cons can be replaced by another object.</li>
      <li>Any element of a vector can be replaced by another object.</li>
      <li>The value of a binding can be replaced by another object.</li>
      <li>A binding can be added to or deleted from an environment.</li>
    </ul>
    <p>(As explained above, what replacing an object by another object really means is replacing a reference to an object by a reference to another object.)</p>
    <p>The life cycle of an object, binding, or environment consists of the following events: a creation (which consists of an allocation followed by an initialization) followed by any number of alterations followed by a destruction (which consists of a deallocation). Alterations are possible only if the object, binding, or environment is mutable.</p>
    <p>The destruction of an object, binding, or environment occurs automatically if and when the object, binding, or environment becomes unreachable. The rules used to determine if an object, binding, or environment is reachable are as follows (the concepts of global environment and control stack will be introduced later in this section):</p>
    <ul>
      <li>The symbols referenced from the packages are reachable.</li>
      <li>The global environment is reachable.</li>
      <li>An object, binding, or environment referenced from the currently active control stack is reachable.</li>
      <li>An object, binding, or environment referenced from a reachable object, binding, or environment is reachable.</li>
    </ul>
    <p>The garbage collector is the component of the programming language responsible for the automatic destruction of unreachable objects, bindings, and environments.</p>
    <p>Objects treated as code are called forms. A form is executed by being submitted to a component of the programming language called the evaluator. (The form is said to be evaluated.) The evaluation of a form has three possible outcomes:</p>
    <ul>
      <li>The evaluation can complete normally and produce a result consisting of zero or more objects&mdash;object references actually&mdash;called the values of the form. (The form is said to evaluate to the values.)</li>
      <li>The evaluation can complete abnormally because of an error. An evaluation that completes abnormally does not produce any result.</li>
      <li>The evaluation can get caught in an infinite loop and never complete.</li>
    </ul>
    <p>The primary value of a form whose evaluation completed normally is defined as follows: If the result consists of one or more objects, then the primary value of the form is the first object. Otherwise, the primary value of the form is <code>#v</code>.</p>
    <p>Forms submitted to the evaluator through a <a href="#listener-buffers">listener buffer</a>, through the <a href="#evaluate-form">Evaluate Form</a> command, or through the <a href="#load-buffer">Load Buffer</a> command are called top-level forms. A consequence of the evaluation rules stated later in this section is that the evaluation of a top-level form usually entails the evaluation of other non-top-level forms.</p>
    <p>Execution of EVLambda code is achieved through interpretation or compilation.</p>
    <p>An interpreter for a language $X$ is a program capable of directly executing code written in language $X$. Language $X$ is called the source language of the interpreter. A compiler for a language $X$ is a program capable of translating code written in language $X$ into code written in a language $Y$. Language $X$ is called the source language of the compiler and language $Y$ is called the target language of the compiler. Code handed to an interpreter or compiler is called source code. A file containing source code is called a source file. Code produced by a compiler is called compiled code. A file containing compiled code is called a compiled file.</p>
    <p>An interpreter-based EVLambda evaluator executes EVLambda code by submitting the EVLambda code to its embedded EVLambda interpreter. A compiler-based EVLambda evaluator executes EVLambda code by first submitting the EVLambda code to its embedded EVLambda compiler and then arranging for the compiled code to be executed. Interpretation of EVLambda code and execution of compiled code occur at a time called run time. Compilation of EVLambda code occurs at a time called compile time.</p>
    <p>EVLambda source files contain not only EVLambda source code but also documentation in XML format. Documentation is ignored by interpreters and compilers but can be converted to HTML, together with the EVLambda source code, by a component of the programming language called the documentation generator.</p>
    <p>Each evaluation is done with respect to three environments: a global environment, a lexical environment, and a dynamic environment. The reference manual will introduce the concepts of scope and extent. The different environments draw their names from the scope and extent of their bindings:</p>
    <ul>
      <li>A global environment contains bindings with indefinite scope and indefinite extent.</li>
      <li>A lexical environment contains bindings with lexical scope and indefinite extent.</li>
      <li>A dynamic environment contains bindings with indefinite scope and dynamic extent.</li>
    </ul>
    <p>The fact that a global/lexical/dynamic environment contains bindings with such scope and such extent is a direct consequence of the evaluation rules stated later in this section. It is thus not necessary to know the concepts of scope and extent to start writing programs in EVLambda. Knowing the evaluation rules should be enough.</p>
    <p>Evaluations are all done with respect to the same global environment. That environment, referred to as &ldquo;the global environment&rdquo;, is created when the evaluator starts and continues to exist until the evaluator stops. The global environment of an evaluator that has just started contains a set of predefined bindings, most of which providing access to a primitive function. As forms are evaluated, the global environment can change in the following ways:</p>
    <ul>
      <li>Bindings can be added.</li>
      <li>Bindings can be deleted.</li>
      <li>Bindings can be altered.</li>
    </ul>
    <p>Evaluations are not all done with respect to the same lexical and dynamic environments. The lexical environment and the dynamic environments with respect to which a form is evaluated are referred to as &ldquo;the current lexical environment&rdquo; and &ldquo;the current dynamic environment&rdquo;, respectively.</p>
    <p>Top-level forms are evaluated with respect to an initial lexical environment and an initial dynamic environment that are both empty.</p>
    <p>A consequence of the evaluation rules stated later in this section is that non-top-level forms are evaluated with respect to (1) a lexical environment that is either the initial empty lexical environment or the result of extending, once or multiple times in sequence, the initial empty lexical environment and (2) a dynamic environment that is either the initial empty dynamic environment or the result of extending, once or multiple times in sequence, the initial empty dynamic environment.</p>
    <p>Let $\env$ be an environment, $\ns$ be a namespace of the environment, $n$ be a nonnegative integer, $\var_1$, &hellip;, $\var_n$ be a sequence of $n$ distinct variables, and $\obj_1$, &hellip;, $\obj_n$ be a sequence of $n$ objects. The environment extending the environment $\env$ to bind, in the namespace $\ns$, the variable $\var_i$ to the object $\obj_i$ (for all $i$ from $1$ to $n$) is the environment obtained as follows:</p>
    <ol>
      <li>Copy the environment $\env$ in such a way that (1) the environment $\env$ and its copy are distinct (steps 2 and 3 below must have no effect on the environment $\env$) and (2) the environment $\env$ and its copy contain the exact same bindings (the bindings are not copied but shared between the two environments).</li>
      <li>For all $i$ from $1$ to $n$, delete from the copy of the namespace $\ns$ the binding for the variable $\var_i$, if it exists.</li>
      <li>For all $i$ from $1$ to $n$, add to the copy of the namespace $\ns$ a new binding between the variable $\var_i$ and the object $\obj_i$.</li>
    </ol>
    <p>A binding deleted from the environment in step 2 is said to be shadowed by the binding for the same variable added to the environment in step 3. The extended environment is nonempty unless the environment being extended is empty and $n$ is equal to zero.</p>
    <p>Two additional consequences of the evaluation rules stated later in this section are that (1) the function namespace of a dynamic environment is always empty and (2) bindings are never added to or deleted from a lexical or dynamic environment after the environment has been created (that is, after the three steps mentioned above).</p>
    <p>Together, the global environment, the current lexical environment, and the current dynamic environment can contain up to five bindings for any given variable:</p>
    <ul>
      <li>One in the value namespace of the global environment.</li>
      <li>One in the function namespace of the global environment.</li>
      <li>One in the value namespace of the current lexical environment.</li>
      <li>One in the function namespace of the current lexical environment.</li>
      <li>One in the value namespace of the current dynamic environment.</li>
    </ul>
    <p>Three pairs of operations are provided to get and set the values of the aforementioned bindings. Each pair uses a specific lookup rule to select one of the bindings. In each pair, one operation is used to get the value of the selected binding (the operation fails if the lookup rule fails to select a binding) and one operation is used to set the value of the selected binding (a new binding is added to the global environment if the lookup rule fails to select a binding). The lookup rules used by the operations are stated below. The operations themselves are detailed later in this section.</p>
    <p>The operations <code>vref</code> (getter) and <code>vset!</code> (setter) use the following lookup rule:</p>
    <ul>
      <li>Select the binding for the variable in the value namespace of the current lexical environment, if the binding exists.</li>
      <li>Otherwise, select the binding for the variable in the value namespace of the global environment, if the binding exists.</li>
      <li>Otherwise, fail to select a binding.</li>
    </ul>
    <p>The operations <code>fref</code> (getter) and <code>fset!</code> (setter) use the following lookup rule:</p>
    <ul>
      <li>Select the binding for the variable in the function namespace of the current lexical environment, if the binding exists.</li>
      <li>Otherwise, select the binding for the variable in the function namespace of the global environment, if the binding exists.</li>
      <li>Otherwise, fail to select a binding.</li>
    </ul>
    <p>The operations <code>dref</code> (getter) and <code>dset!</code> (setter) use the following lookup rule:</p>
    <ul>
      <li>Select the binding for the variable in the value namespace of the current dynamic environment, if the binding exists.</li>
      <li>Otherwise, select the binding for the variable in the value namespace of the global environment, if the binding exists.</li>
      <li>Otherwise, fail to select a binding.</li>
    </ul>
    <p>A consequence of the lookup rules is that a binding in the value/function namespace of the current lexical/dynamic environment will effectively shadow a binding for the same variable in the value/function namespace of the global environment.</p>
    <p>A global variable is a binding between a variable and an object (of any type) in the value namespace of the global environment, or the name or value of such binding. A global function is a binding between a variable and a function other than a macro in the function namespace of the global environment, or the name or value of such binding. A global macro is a binding between a variable and a macro in the function namespace of the global environment, or the name or value of such binding. Global variables, global functions, and global macros are created and altered using language constructs called global definitions.</p>
    <p>A local variable is a binding between a variable and an object (of any type) in the value namespace of a lexical environment, or the name or value of such binding. A local function is a binding between a variable and a function other than a macro in the function namespace of a lexical environment, or the name or value of such binding. A local macro is a binding between a variable and a macro in the function namespace of a lexical environment, or the name or value of such binding. A dynamic variable is a binding between a variable and an object (of any type) in the value namespace of a dynamic environment, or the name or value of such binding. Local variables, local functions, local macros, and dynamic variables are created (but not altered) using language constructs called binding constructs.</p>
    <p>When a form is submitted to the evaluator, the evaluator analyzes the form to determine how to evaluate it. If the form is the empty list, then the evaluation completes abnormally. Otherwise, if the form is neither a variable nor a cons, then the result of the evaluation is the form itself. (Objects that are neither the empty list, nor a variable, nor a cons are said to be self-evaluating.) Otherwise, if the form is a variable $\var$, then the variable is treated as an abbreviation for either <code>(vref $\var$)</code> or <code>(fref $\var$)</code>, depending on the context of its occurrence. Otherwise, the form is necessarily a cons and the evaluation completes abnormally unless the form matches one of the following patterns:</p>
    <ol>
      <li><code>(quote $\metavar{literal}$)</code></li>
      <li><code>(progn $\metavar{serial-forms}$)</code></li>
      <li><code>(if $\metavar{test-form}$ $\metavar{then-form}$ $\metavar{else-form}$)</code></li>
      <li><code>(_vlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></li>
      <li><code>(_mlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></li>
      <li><code>(_flambda $\metavar{parameter-list}$ $\metavar{body}$)</code></li>
      <li><code>(_dlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></li>
      <li><code>(vref $\metavar{variable}$)</code></li>
      <li><code>(vset! $\metavar{variable}$ $\metavar{value-form}$)</code></li>
      <li><code>(fref $\metavar{variable}$)</code></li>
      <li><code>(fset! $\metavar{variable}$ $\metavar{value-form}$)</code></li>
      <li><code>(dref $\metavar{variable}$)</code></li>
      <li><code>(dset! $\metavar{variable}$ $\metavar{value-form}$)</code></li>
      <li><code>(apply $\metavar{operator-form}$ $\metavar{operand-forms}$)</code></li>
      <li><code>(multiple-value-call $\metavar{operator-form}$ $\metavar{operand-forms}$)</code></li>
      <li><code>(multiple-value-apply $\metavar{operator-form}$ $\metavar{operand-forms}$)</code></li>
      <li><code>($\metavar{macro-operator}$ $\metavar{macro-operands}$)</code></li>
      <li><code>($\metavar{operator-form}$ $\metavar{operand-forms}$)</code></li>
    </ol>
    <p>Names enclosed in angle brackets have the following meanings:</p>
    <ul>
      <li>$\metavar{literal}$ matches any object</li>
      <li>$\metavar{serial-forms}$ matches any sequence of zero or more objects</li>
      <li>$\metavar{test-form}$ matches any object</li>
      <li>$\metavar{then-form}$ matches any object</li>
      <li>$\metavar{else-form}$ matches any object</li>
      <li>$\metavar{parameter-list}$ matches any list of distinct variables (as we will see in the reference manual, a parameter list can actually take two other forms)</li>
      <li>$\metavar{body}$ matches any sequence of zero or more objects</li>
      <li>$\metavar{variable}$ matches any variable</li>
      <li>$\metavar{value-form}$ matches any object</li>
      <li>$\metavar{operator-form}$ matches any object</li>
      <li>$\metavar{operand-forms}$ matches any sequence of zero or more objects</li>
      <li>$\metavar{macro-operator}$ matches any variable naming a macro according to the lookup rule used by <code>fref</code></li>
      <li>$\metavar{macro-operands}$ matches any sequence of zero or more objects</li>
    </ul>
    <p>By way of example, a form matches the first pattern if and only if it is a list of two elements whose first element is the variable <code>quote</code>.</p>
    <p>The patterns are tried in sequence and the first matching pattern wins.</p>
    <p>A form matching one of the first sixteen patterns is called a special form and the variables <code>quote</code>, <code>progn</code>, <code>if</code>, <code>_vlambda</code>, <code>_mlambda</code>, <code>_flambda</code>, <code>_dlambda</code>, <code>vref</code>, <code>vset!</code>, <code>fref</code>, <code>fset!</code>, <code>dref</code>, <code>dset!</code>, <code>apply</code>, <code>multiple-value-call</code>, and <code>multiple-value-apply</code> are called special operators.</p>
    <p>Special forms matching patterns 4 (<code>_vlambda</code>), 5 (<code>_mlambda</code>), 6 (<code>_flambda</code>), and 7 (<code>_dlambda</code>) are called lambda abstractions. Lambda abstractions are the fundamental binding constructs from which all other binding constructs are built. Forms consisting of a variable and special forms matching patterns 8 (<code>vref</code>), 10 (<code>fref</code>), and 12 (<code>dref</code>) are called variable references. Special forms matching patterns 9 (<code>vset!</code>), 11 (<code>fset!</code>), and 13 (<code>dset!</code>) are called variable assignments. Forms matching pattern 17 are called macro calls. Forms matching pattern 18 are called plain function calls.</p>
    <p>The rule regarding forms consisting of a variable is the following: If a variable $\var$ occurs in operator position, then the variable is treated as an abbreviation for <code>(fref $\var$)</code> and the function namespace is used. Otherwise, the variable is treated as an abbreviation for <code>(vref $\var$)</code> and the value namespace is used. For example, the plain function call <code>(f x)</code> would be treated as an abbreviation for <code>((fref f) (vref x))</code>. The full forms <code>(fref $\var$)</code> and <code>(vref $\var$)</code> can always be used to force the use of a specific namespace.</p>
    <p>As we will see below, the evaluation of a form containing subforms entails the evaluation of some or all of the subforms. When a subform is evaluated, the following rules apply:</p>
    <ul>
      <li>The subform is evaluated with respect to the same lexical and dynamic environments as the containing form. (But see below how closures are invoked.)</li>
      <li>If the evaluation of the subform completes abnormally, then the evaluation of the containing form also completes abnormally.</li>
      <li>If the evaluation of the subform does not complete, then the evaluation of the containing form does not complete either.</li>
    </ul>
    <p>Special forms, macro calls, and plain function calls are evaluated as follows:</p>
    <dl>
      <dt><code>(quote $\metavar{literal}$)</code></dt>
      <dd>The <code>quote</code>-form evaluates to the unevaluated literal. Using a <code>quote</code>-form, any object can be treated as data. For any object $\obj$, <code>(quote $\obj$)</code> can be abbreviated to <code>'$\obj$</code>.</dd>
      <dt><code>(progn $\metavar{serial-forms}$)</code></dt>
      <dd>The serial-forms are evaluated in sequence from left to right. If there is at least one serial-form, then the <code>progn</code>-form evaluates to the values of the last serial-form. Otherwise, the <code>progn</code>-form evaluates to <code>#v</code>.</dd>
      <dt><code>(if $\metavar{test-form}$ $\metavar{then-form}$ $\metavar{else-form}$)</code></dt>
      <dd>The test-form is evaluated. Let $\primval$ be the primary value of the test-form. If $\primval$ is not a boolean, then the evaluation of the <code>if</code>-form completes abnormally. If $\primval$ is the boolean <code>#t</code>, then the then-form is evaluated and the <code>if</code>-form evaluates to the values of the then-form. If $\primval$ is the boolean <code>#f</code>, then the else-form is evaluated and the <code>if</code>-form evaluates to the values of the else-form.</dd>
      <dt><code>(_vlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></dt>
      <dt><code>(_mlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></dt>
      <dt><code>(_flambda $\metavar{parameter-list}$ $\metavar{body}$)</code></dt>
      <dt><code>(_dlambda $\metavar{parameter-list}$ $\metavar{body}$)</code></dt>
      <dd>A lambda abstraction evaluates to a closure recording the following two pieces of information: the lambda abstraction and the current lexical environment (which is said to be captured by the closure). A closure resulting from the evaluation of an <code>_mlambda</code>-form is tagged as being a macro.</dd>
      <dt><code>(vref $\metavar{variable}$)</code></dt>
      <dd>If there exists a binding for the variable in the value namespace of the current lexical environment, then the <code>vref</code>-form evaluates to the value of that binding. Otherwise, if there exists a binding for the variable in the value namespace of the global environment, then the <code>vref</code>-form evaluates to the value of that binding. Otherwise, the evaluation of the <code>vref</code>-form completes abnormally.</dd>
      <dt><code>(vset! $\metavar{variable}$ $\metavar{value-form}$)</code></dt>
      <dd>The value-form is evaluated. Let $\primval$ be the primary value of the value-form. If there exists a binding for the variable in the value namespace of the current lexical environment, then the value of that binding is replaced by $\primval$. Otherwise, if there exists a binding for the variable in the value namespace of the global environment, then the value of that binding is replaced by $\primval$. Otherwise, a new binding between the variable and $\primval$ is added to the value namespace of the global environment. In all three cases, the <code>vset!</code>-form evaluates to $\primval$.</dd>
      <dt><code>(fref $\metavar{variable}$)</code></dt>
      <dd>If there exists a binding for the variable in the function namespace of the current lexical environment, then the <code>fref</code>-form evaluates to the value of that binding. Otherwise, if there exists a binding for the variable in the function namespace of the global environment, then the <code>fref</code>-form evaluates to the value of that binding. Otherwise, the evaluation of the <code>fref</code>-form completes abnormally.</dd>
      <dt><code>(fset! $\metavar{variable}$ $\metavar{value-form}$)</code></dt>
      <dd>The value-form is evaluated. Let $\primval$ be the primary value of the value-form. If there exists a binding for the variable in the function namespace of the current lexical environment, then the value of that binding is replaced by $\primval$. Otherwise, if there exists a binding for the variable in the function namespace of the global environment, then the value of that binding is replaced by $\primval$. Otherwise, a new binding between the variable and $\primval$ is added to the function namespace of the global environment. In all three cases, the <code>fset!</code>-form evaluates to $\primval$.</dd>
      <dt><code>(dref $\metavar{variable}$)</code></dt>
      <dd>If there exists a binding for the variable in the value namespace of the current dynamic environment, then the <code>dref</code>-form evaluates to the value of that binding. Otherwise, if there exists a binding for the variable in the value namespace of the global environment, then the <code>dref</code>-form evaluates to the value of that binding. Otherwise, the evaluation of the <code>dref</code>-form completes abnormally.</dd>
      <dt><code>(dset! $\metavar{variable}$ $\metavar{value-form}$)</code></dt>
      <dd>The value-form is evaluated. Let $\primval$ be the primary value of the value-form. If there exists a binding for the variable in the value namespace of the current dynamic environment, then the value of that binding is replaced by $\primval$. Otherwise, if there exists a binding for the variable in the value namespace of the global environment, then the value of that binding is replaced by $\primval$. Otherwise, a new binding between the variable and $\primval$ is added to the value namespace of the global environment. In all three cases, the <code>dset!</code>-form evaluates to $\primval$.</dd>
      <dt><code>(apply $\metavar{operator-form}$ $\metavar{operand-forms}$)</code></dt>
      <dt><code>(multiple-value-call $\metavar{operator-form}$ $\metavar{operand-forms}$)</code></dt>
      <dt><code>(multiple-value-apply $\metavar{operator-form}$ $\metavar{operand-forms}$)</code></dt>
      <dd>Variants of the plain function call described below. Those variants are described in the reference manual.</dd>
      <dt><code>($\metavar{macro-operator}$ $\metavar{macro-operands}$)</code></dt>
      <dd>Following the definition of a macro call, the macro-operator matches a variable naming a macro according to the lookup rule used by <code>fref</code>. That macro is invoked on the unevaluated macro-operands. If the invocation completes abnormally, then the evaluation of the macro call also completes abnormally. Otherwise, if the invocation does not complete, then the evaluation of the macro call does not complete either. Otherwise, the primary value of the invocation, which is called the expansion of the macro call, is evaluated with respect to the current lexical and dynamic environments. If the evaluation of the expansion completes abnormally, then the evaluation of the macro call also completes abnormally. Otherwise, if the evaluation of the expansion does not complete, then the evaluation of the macro call does not complete either. Otherwise, the macro call evaluates to the values of the expansion.</dd>
      <dt><code>($\metavar{operator-form}$ $\metavar{operand-forms}$)</code></dt>
      <dd>The operator-form and the operand-forms are evaluated in sequence from left to right. If the primary value of the operator-form is not a function, then the evaluation of the plain function call completes abnormally. Otherwise, the primary value of the operator-form is invoked on the primary values of the operand-forms. If the invocation completes abnormally, then the evaluation of the plain function call also completes abnormally. Otherwise, if the invocation does not complete, then the evaluation of the plain function call does not complete either. Otherwise, the plain function call evaluates to the values of the invocation.</dd>
    </dl>
    <p>Invoking a function is what causes the function to compute the output corresponding to an input. The input of an invocation consists of zero or more objects&mdash;object references actually&mdash;called the arguments of the invocation. (The function is said to be invoked on the arguments and the arguments are said to be passed to the function.) The invocation of a function has three possible outcomes:</p>
    <ul>
      <li>The invocation can complete normally and produce an output consisting of zero or more objects&mdash;object references actually&mdash;called the values of the invocation. (The function is said to return the values.)</li>
      <li>The invocation can complete abnormally because of an error. An invocation that completes abnormally does not produce any output.</li>
      <li>The invocation can get caught in an infinite loop and never complete.</li>
    </ul>
    <p>The primary value of an invocation that completed normally is defined as follows: If the output consists of one or more objects, then the primary value of the invocation is the first object. Otherwise, the primary value of the invocation is <code>#v</code>.</p>
    <p>The verbs &ldquo;accept&rdquo; and &ldquo;return&rdquo; are often used to describe the input/output mapping implemented by a function. For example, we could describe a function by saying that the function accepts two numbers and returns the sum of their squares.</p>
    <p>A primitive function is invoked as follows:</p>
    <blockquote>Let's assume that, as is the case with all the evaluators currently available, the primitive function is implemented by a JavaScript function accepting (an encoding of) the arguments of the invocation of the primitive function and returning (an encoding of) the values of the invocation of the primitive function. The JavaScript function is invoked on the arguments. If the invocation of the JavaScript function completes abnormally, then the invocation of the primitive function also completes abnormally. Otherwise, if the invocation of the JavaScript function does not complete, then the invocation of the primitive function does not complete either. Otherwise, the primitive function returns the values returned by the JavaScript function.</blockquote>
    <p>A closure is invoked as follows:</p>
    <blockquote>
      <p>If the number of variables in the parameter list of the lambda abstraction recorded by the closure and the number of arguments are different, then the invocation completes abnormally. (As we will see in the reference manual, it is actually possible to create closures accepting a variable number of arguments.) Otherwise, let $\var_1$, &hellip;, $\var_n$ be the variables composing the parameter list of the lambda abstraction recorded by the closure, $\arg_1$, &hellip;, $\arg_n$ be the arguments, and $\lexenv$ and $\dynenv$ be the following environments:</p>
      <ul>
        <li>If the closure results from the evaluation of a <code>_vlambda</code>-form or an <code>_mlambda</code>-form, then $\lexenv$ is the environment extending the lexical environment recorded by the closure to bind, in the value namespace, the variable $\var_i$ to the argument $\arg_i$ (for all $i$ from $1$ to $n$) and $\dynenv$ is the current dynamic environment.</li>
        <li>If the closure results from the evaluation of an <code>_flambda</code>-form, then $\lexenv$ is the environment extending the lexical environment recorded by the closure to bind, in the function namespace, the variable $\var_i$ to the argument $\arg_i$ (for all $i$ from $1$ to $n$) and $\dynenv$ is the current dynamic environment.</li>
        <li>If the closure results from the evaluation of a <code>_dlambda</code>-form, then $\lexenv$ is the lexical environment recorded by the closure and $\dynenv$ is the environment extending the current dynamic environment to bind, in the value namespace, the variable $\var_i$ to the argument $\arg_i$ (for all $i$ from $1$ to $n$).</li>
      </ul>
      <p>The objects composing the body of the lambda abstraction recorded by the closure are evaluated with respect to $\lexenv$ and $\dynenv$ as if they were the serial-forms of a <code>progn</code>-form. If the evaluation of the <code>progn</code>-form completes abnormally, then the invocation also completes abnormally. Otherwise, if the evaluation of the <code>progn</code>-form does not complete, then the invocation does not complete either. Otherwise, the closure returns the values of the <code>progn</code>-form.</p>
    </blockquote>
    <p>The special operators <code>_vlambda</code>, <code>_mlambda</code>, <code>_flambda</code>, and <code>_dlambda</code> have an underscore at the beginning of their names to distinguish them from the similarly named macros <code>vlambda</code>, <code>mlambda</code>, <code>flambda</code>, and <code>dlambda</code>. The purpose of those macros is to facilitate the creation of closures accepting a variable number of arguments.</p>
    <p>The evaluator uses a data structure called the control stack to coordinate its activities. Each time a top-level form is submitted to the evaluator, a new control stack is created that will be used throughout the evaluation of the form. The same control stack is used to evaluate the top-level form and all non-top-level forms whose evaluations are entailed by the evaluation of the top-level form.</p>
    <p>An evaluation/invocation that completes normally produces a result/output consisting of zero or more objects. The production of that result/output, which only occurs if the evaluation/invocation completes normally, is the primary effect of the evaluation/invocation. In addition to or in place of its primary effect, an evaluation/invocation can also have secondary effects called side effects. Examples of side effects are:</p>
    <ul>
      <li>The abnormal completion of the evaluation/invocation.</li>
      <li>The noncompletion of the evaluation/invocation.</li>
      <li>The consumption of time.</li>
      <li>The consumption of memory.</li>
      <li>The alteration of a cons, vector, or binding.</li>
      <li>The addition of a binding to the global environment.</li>
      <li>The deletion of a binding from the global environment.</li>
      <li>The transfer of information from the outside world to the form/function (an input operation).</li>
      <li>The transfer of information from the form/function to the outside world (an output operation).</li>
    </ul>
    <p>A consequence of the existence of side effects is that the repeated evaluations of the same form or the repeated invocations of the same function on the same arguments do not necessarily have the same outcome and, if they complete normally, do not necessarily produce the same result/output.</p>
    <p>It is customary for a special operator, function, or macro that can alter an object, binding, or environment to have a name ending with an exclamation mark. This explains the exclamation mark in the names of the special operators <code>vset!</code>, <code>fset!</code>, and <code>dset!</code>.</p>
    <h2>Integrated Development Environment</h2>
    <p>The integrated development environment (IDE) is a web application that can run either from the EVLambda web server (online mode) or from a web server running on your machine (offline mode). The code running in the web browser is exactly the same in both modes but the behavior of the IDE is slightly different because the backends have different capabilities.</p>
    <p>The IDE's graphical user interface consists of a menu bar at the top left, an info bar at the top right, a minibuffer at the bottom, and a set of windows in the main area. Each window consists of a contents area and a status bar. At any given time, a window displays the contents of a buffer, of which there are two types: the file buffers and the listener buffers. A given buffer can be displayed in any number of windows (including zero) and any buffer can be displayed in any window. This organization around buffers and windows is borrowed from the <a href="https://www.gnu.org/software/emacs/" target="_blank">Emacs</a> text editor.</p>
    <p>A file buffer is a buffer whose contents reflects the contents of a file. The contents of the buffer is read from the file through open and revert operations and written into the file through save operations. When a window displays the contents of a file buffer, its status bar displays the name of the file, followed by a star when the current contents of the buffer differs from the contents that was last read from or written into the file.</p>
    <p>When the IDE starts, it automatically opens a predefined set of files. In online mode, the files are located in a directory on the machine hosting the EVLambda web server. In offline mode, the files are located in the directory <code>&lt;EVLAMBDA_HOME&gt;/system-files</code> on your machine.</p>
    <p>A listener buffer is a buffer that allows you to evaluate forms interactively. When a window displays the contents of a listener buffer, its status bar displays the name of the buffer. Currently, the IDE has exactly one listener buffer whose name is &ldquo;Listener&nbsp;1&rdquo;.</p>
    <p>At any given time, there is exactly one selected window and, by extension, exactly one selected buffer. The status bar of the selected window is darker than the status bar of the nonselected windows. A window becomes the selected window when it receives the focus, which happens for instance when it receives a click event.</p>
    <p>Currently, the only function of the minibuffer is to display messages and evaluation results.</p>
    <h2>File Buffers</h2>
    <p>A window can display the contents of a file buffer in one of two modes: raw mode or HTML mode. In raw mode, the contents of the buffer is displayed in the <a href="https://codemirror.net/" target="_blank">CodeMirror</a> text editor. In HTML mode, the contents of the buffer, or some HTML contents derived from the contents of the buffer, is displayed in an HTML viewer.</p>
    <p>The all-caps files (USER-MANUAL, &hellip;), which are actually HTML files, can be displayed in raw mode or HTML mode. The EVLambda source files (extension <code>.evl</code>), which contain a mix of EVLambda source code and documentation in XML format, can be displayed in raw mode or HTML mode. The other types of files are always displayed in raw mode.</p>
    <h2 id="listener-buffers">Listener Buffers</h2>
    <p>A listener buffer allows you to evaluate forms interactively. To evaluate a form in a listener buffer, you type in a readable representation of the form after the prompt and press the Return or Enter key when the cursor is at the very end of the buffer. In response, the form is evaluated, the printable representations of the resulting values are printed separated by a newline, and a new prompt is printed, allowing you to evaluate another form. This sequence of operations is called a read-eval-print loop (REPL).</p>
    <p>Notes:</p>
    <ul>
      <li>The prompt is the greater-than sign printed at the beginning of a line to inform you that the listener buffer is waiting for a form to be typed in.</li>
      <li>If you press the Return or Enter key when (1) the cursor is not at the very end of the buffer or (2) the form is missing or incomplete, then a newline is simply inserted into the buffer and no evaluation takes place.</li>
      <li>If the evaluation completes abnormally, then a message describing the error is printed in place of the printable representations of the (nonexisting) resulting values.</li>
      <li>If the evaluation does not complete, then you must abort the evaluation or restart the evaluator in order to get a new prompt.</li>
    </ul>
    <p>We will now illustrate some of the concepts introduced in the section <a href="#programming-language">Programming Language</a> by providing a commented transcript of a sequence of evaluations conducted in a listener buffer. If you want to reproduce the evaluations, be sure to start with a fresh Trampoline++ evaluator. To get a fresh Trampoline++ evaluator, restart the evaluator (using the Restart Evaluator&hellip; command from the Eval menu) with Trampoline++ selected as the evaluator type.</p>
    <p>The global functions used in the evaluations are listed below. For each function, a template function call and a description of the function are provided. The variable in operator position is the name of the function (i.e., the variable bound to the function in the function namespace of the global environment).</p>
    <dl>
      <dt><code>(car $\cons$)</code></dt>
      <dd>The function <code>car</code> returns the first element of its argument, which must be of type <code>cons</code>.</dd>
      <dt><code>(cdr $\cons$)</code></dt>
      <dd>The function <code>cdr</code> returns the second element of its argument, which must be of type <code>cons</code>.</dd>
      <dt><code>(list $\object_1\ldots\object_n$)</code></dt>
      <dd>The function <code>list</code> collects its arguments, which can be of any types, into a list: when invoked on the arguments $\object_1$, &hellip;, $\object_n$, the function returns a list whose elements are $\object_1$, &hellip;, $\object_n$.</dd>
      <dt><code>(+ $\number_1\ldots\number_n$)</code></dt>
      <dd>The function <code>+</code> returns the sum of its arguments, which must be of type <code>number</code>.</dd>
      <dt><code>(* $\number_1\ldots\number_n$)</code></dt>
      <dd>The function <code>*</code> returns the product of its arguments, which must be of type <code>number</code>.</dd>
      <dt><code>(values $\object_1\ldots\object_n$)</code></dt>
      <dd>The function <code>values</code> converts its arguments, which can be of any types, into values: when invoked on the arguments $\object_1$, &hellip;, $\object_n$, the function returns the values $\object_1$, &hellip;, $\object_n$.</dd>
    </dl>
    <p>The global macros used in the evaluations are listed below. For each macro, a template macro call and a description of the macro are provided. The variable in operator position is the name of the macro (i.e., the variable bound to the macro in the function namespace of the global environment).</p>
    <dl>
      <dt><code>(vdef $\metavar{variable}$ $\metavar{value-form}$)</code></dt>
      <dd>The purpose of the macro <code>vdef</code> is to define a global variable by ensuring that the variable is bound in the value namespace of the global environment to the primary value of the value-form. The macro call evaluates to the variable.</dd>
      <dt><code>(fdef $\metavar{variable}$ $\metavar{parameter-list}$ $\metavar{body}$)</code></dt>
      <dd>The purpose of the macro <code>fdef</code> is to define a global function by ensuring that the variable is bound in the function namespace of the global environment to the closure resulting from the evaluation of the <code>_vlambda</code>-form <code>(_vlambda $\metavar{parameter-list}$ $\metavar{body}$)</code>. The macro call evaluates to the variable.</dd>
      <dt><code>(loop $\metavar{serial-forms}$)</code></dt>
      <dd>The purpose of the macro <code>loop</code> is to create an infinite loop repeatedly evaluating the serial-forms in sequence from left to right. For example, the macro call <code>(loop)</code> endlessly does nothing. The evaluation of the macro call normally does not complete but there are ways to exit an infinite loop.</dd>
    </dl>
    <p>Here is the commented transcript, where each gray box contains a form and its values. The character &#x23CE; marks the places where the Return or Enter key should be pressed.</p>
    <pre class="repl">&gt; (+ 1 2)&#x23CE;<br>3</pre>
    <p>The evaluation produces a result consisting of the sum of the two numbers <code>1</code> and <code>2</code>. Because numbers are self-evaluating, quoting the numbers is not necessary.</p>
    <pre class="repl">&gt; (+ '1 '2)&#x23CE;<br>3</pre>
    <p>The evaluation produces the same result if the numbers are quoted. Quoting self-evaluating objects is unidiomatic, though.</p>
    <pre class="repl">&gt; (car '(1 2 3))&#x23CE;<br>1</pre>
    <p>The evaluation produces a result consisting of the first element of the list <code>(1 2 3)</code>. Because lists are not self-evaluating, quoting the list is necessary.</p>
    <pre class="repl">&gt; (car (1 2 3))&#x23CE;<br>ERROR: The operator-form does not evaluate to a function.</pre>
    <p>The evaluation completes abnormally if the list is not quoted. The reason is as follows: The evaluator treats the list <code>(1 2 3)</code> as a plain function call and the operator-form, the number <code>1</code>, does not evaluate to a function.</p>
    <pre class="repl">&gt; (cdr '(1 2 3))&#x23CE;<br>(2 3)</pre>
    <p>The evaluation produces a result consisting of the sublist of the list <code>(1 2 3)</code> obtained by omitting its first element.</p>
    <pre class="repl">&gt; (car (cdr '(1 2 3)))&#x23CE;<br>2</pre>
    <p>The evaluation produces a result consisting of the second element of the list <code>(1 2 3)</code>.</p>
    <pre class="repl">&gt; (cdr (cdr '(1 2 3)))&#x23CE;<br>(3)</pre>
    <p>The evaluation produces a result consisting of the sublist of the list <code>(1 2 3)</code> obtained by omitting its first two elements.</p>
    <pre class="repl">&gt; (car (cdr (cdr '(1 2 3))))&#x23CE;<br>3</pre>
    <p>The evaluation produces a result consisting of the third element of the list <code>(1 2 3)</code>.</p>
    <pre class="repl">&gt; (cdr (cdr (cdr '(1 2 3))))&#x23CE;<br>()</pre>
    <p>The evaluation produces a result consisting of the sublist of the list <code>(1 2 3)</code> obtained by omitting its first three elements.</p>
    <pre class="repl">&gt; (car (cdr (cdr (cdr '(1 2 3)))))&#x23CE;<br>ERROR: The 1st argument is not of type EVLCons.</pre>
    <p>The evaluation completes abnormally because the empty list is not a cons.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>ERROR: The variable 'disk-area' is unbound in the FUNCTION namespace.</pre>
    <p>The evaluation completes abnormally because the global function <code>disk-area</code> is undefined.</p>
    <pre class="repl">&gt; (fdef disk-area (r) (* 3.14 r r))&#x23CE;<br>disk-area</pre>
    <p>The evaluation produces a result consisting of the variable <code>disk-area</code>. More importantly, the evaluation has the side effect of defining the global function <code>disk-area</code>. In its intended usage, the function accepts the radius of a disk and returns the area of the disk computed using <code>3.14</code> as the value of pi. When the function is invoked, its body is evaluated with respect to a lexical environment binding, in the value namespace, the variable <code>r</code> to the argument of the invocation (that is, the radius of the disk).</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>12.56</pre>
    <p>The evaluation produces the expected result.</p>
    <pre class="repl">&gt; (fdef disk-area (r) (* 3.1416 r r))&#x23CE;<br>disk-area</pre>
    <p>The evaluation has the side effect of redefining the global function <code>disk-area</code> to compute the area of the disk using <code>3.1416</code> as the value of pi.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>12.5664</pre>
    <p>The evaluation produces the expected result.</p>
    <pre class="repl">&gt; (fdef disk-area (r) (* *pi* r r))&#x23CE;<br>disk-area</pre>
    <p>The evaluation has the side effect of redefining the global function <code>disk-area</code> to compute the area of the disk using the value of the global variable <code>*pi*</code> as the value of pi. It is customary for a global or dynamic variable to have a name starting and ending with an asterisk.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>ERROR: The variable '*pi*' is unbound in the VALUE namespace.</pre>
    <p>The evaluation completes abnormally because the global variable <code>*pi*</code> is undefined.</p>
    <pre class="repl">&gt; (vdef *pi* 3.141593)&#x23CE;<br>*pi*</pre>
    <p>The evaluation produces a result consisting of the variable <code>*pi*</code>. More importantly, the evaluation has the side effect of defining the global variable <code>*pi*</code>.</p>
    <pre class="repl">&gt; *pi*&#x23CE;<br>3.141593</pre>
    <p>The global variable <code>*pi*</code> has the value <code>3.141593</code>.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>12.566372</pre>
    <p>The evaluation produces the expected result.</p>
    <pre class="repl">&gt; (vdef *pi* 3.14159265)&#x23CE;<br>*pi*</pre>
    <p>The evaluation has the side effect of redefining the global variable <code>*pi*</code>.</p>
    <pre class="repl">&gt; *pi*&#x23CE;<br>3.14159265</pre>
    <p>The global variable <code>*pi*</code> has the value <code>3.14159265</code>.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>12.5663706</pre>
    <p>The evaluation produces the expected result.</p>
    <pre class="repl">&gt; (values)&#x23CE;</pre>
    <p>The evaluation produces a result consisting of zero values.</p>
    <pre class="repl">&gt; (values 1)&#x23CE;<br>1</pre>
    <p>The evaluation produces a result consisting of one value: <code>1</code>.</p>
    <pre class="repl">&gt; 1&#x23CE;<br>1</pre>
    <p>Producing a result consisting of one value is the default behavior so using <code>values</code> in this case is unnecessary and unidiomatic.</p>
    <pre class="repl">&gt; (values 1 2)&#x23CE;<br>1<br>2</pre>
    <p>The evaluation produces a result consisting of two values: <code>1</code> and <code>2</code>.</p>
    <pre class="repl">&gt; (list (values) (values 1) 1 (values 1 2))&#x23CE;<br>(#v 1 1 1)</pre>
    <p>The primary values of the forms <code>(values)</code>, <code>(values 1)</code>, <code>1</code>, and <code>(values 1 2)</code> are <code>#v</code>, <code>1</code>, <code>1</code>, and <code>1</code>, respectively.</p>
    <pre class="repl">&gt; (loop)&#x23CE;<br>ABORTED</pre>
    <p>The evaluation is caught in an infinite loop. You can use the Abort Evaluation command from the Eval menu to stop the evaluation and get a new prompt.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>12.5663706</pre>
    <p>Aborting an evaluation has no effect on the global definitions.</p>
    <pre class="repl">&gt; (loop)&#x23CE;<br>TERMINATED</pre>
    <p>The evaluation is caught in an infinite loop. You can use the Restart Evaluator&hellip; command from the Eval menu to stop the evaluation and get a new prompt.</p>
    <pre class="repl">&gt; (disk-area 2)&#x23CE;<br>ERROR: The variable 'disk-area' is unbound in the FUNCTION namespace.</pre>
    <p>Restarting the evaluator erases all global definitions.</p>
    <h2>Menu Bar</h2>
    <h3>File Menu</h3>
    <h4>Save Buffer</h4>
    <p>Writes the contents of the selected file buffer into its associated file.</p>
    <p>This command is not available in online mode.</p>
    <h4>Revert Buffer&hellip;</h4>
    <p>Reverts the contents of the selected file buffer to the contents of its associated file.</p>
    <h3>Edit Menu</h3>
    <h4>Toggle HTML Mode</h4>
    <p>Toggles the selected window between raw and HTML modes.</p>
    <p>This command is only available when the selected window displays the contents of an all-caps file or an EVLambda source file.</p>
    <h4>Clear Listener&hellip;</h4>
    <p>Clears the selected listener buffer.</p>
    <p>All contents before the last prompt is deleted.</p>
    <h3>Eval Menu</h3>
    <h4 id="evaluate-form">Evaluate Form</h4>
    <p>Evaluates a top-level form contained inside the selected file buffer.</p>
    <p>This command is only available when the selected window displays the contents of an EVLambda source file.</p>
    <p>A top-level form is a form that is not contained inside another form.</p>
    <p>The top-level form to evaluate is selected as follows:</p>
    <ul>
      <li>If a top-level form is covering the cursor position, then that form is selected for evaluation.</li>
      <li>Otherwise, if the character directly after the cursor position is the first character of a top-level form, then that form is selected for evaluation.</li>
      <li>Otherwise, if the first nonblank character before the cursor position is the last character of a top-level form, then that form is selected for evaluation.</li>
      <li>Otherwise, no form is selected for evaluation and no evaluation takes place.</li>
    </ul>
    <p>If the evaluation of the top-level form completes normally, then the printable representations of the resulting values are printed in the minibuffer, separated by a comma. If the evaluation of the top-level form completes abnormally, then a message describing the error is printed in the minibuffer. If the evaluation of the top-level form does not complete, then no new evaluation is possible until the evaluation is aborted or the evaluator is restarted.</p>
    <h4 id="load-buffer">Load Buffer</h4>
    <p>Evaluates the top-level forms contained inside the selected file buffer.</p>
    <p>This command is only available when the selected window displays the contents of an EVLambda source file.</p>
    <p>The top-level forms contained inside the selected file buffer are evaluated as if they were part of a <code>progn</code>-form.</p>
    <p>If the evaluation of the <code>progn</code>-form completes normally, then the printable representations of the resulting values are printed in the minibuffer, separated by a comma. If the evaluation of the <code>progn</code>-form completes abnormally, then a message describing the error is printed in the minibuffer. If the evaluation of the <code>progn</code>-form does not complete, then no new evaluation is possible until the evaluation is aborted or the evaluator is restarted.</p>
    <h4>Abort Evaluation</h4>
    <p>Aborts the current evaluation.</p>
    <h4>Restart Evaluator&hellip;</h4>
    <p>Terminates the current evaluator and starts a new one.</p>
    <p>Warning: All global definitions are lost.</p>
    <p>The following evaluators are available:</p>
    <ul>
      <li>Plain Recursive (plainrec)</li>
      <li>Continuation Passing Style (cps)</li>
      <li>Object-Oriented CPS (oocps)</li>
      <li>Stack-Based Object-Oriented CPS (sboocps)</li>
      <li>Trampoline (trampoline)</li>
      <li>Trampoline++ (trampolinepp)</li>
    </ul>
    <p>Only the Trampoline and Trampoline++ evaluators allow unbounded iterations through tail-recursive calls. The other evaluators are only useful as stepping stones to understand the Trampoline and Trampoline++ evaluators. The Trampoline++ evaluator is an optimized version of the Trampoline evaluator.</p>
    <h3>View Menu</h3>
    <h4>Select Other Window</h4>
    <p>Selects one of the nonselected windows.</p>
    <p>This command is not available when the selected window is maximized.</p>
    <h4>Toggle Maximized State</h4>
    <p>Toggles the selected window between unmaximized and maximized states.</p>
    <h3>Buffer Menu</h3>
    <p>The buffer menu allows you to select the buffer displayed in the selected window.</p>
    <p>The buffer menu contains the following entries:</p>
    <ul>
      <li><code>/system/USER-MANUAL</code>: the user manual (this file)</li>
      <li><code>/system/TUTORIAL</code>: the tutorial</li>
      <!--<li><code>/system/REFERENCE-MANUAL</code>: the reference manual</li>-->
      <!--<li><code>/system/IMPLEMENTATION-NOTES</code>: the implementation notes</li>-->
      <li><code>/system/BIBLIOGRAPHY</code>: the bibliography</li>
      <li><code>/system/LICENSE</code>: the license</li>
      <li><code>/system/all-caps.css</code>: the CSS file styling the all-caps files</li>
      <li><code>/system/all-caps.js</code>: the JavaScript file loaded by the all-caps files</li>
      <li><code>/system/core.js</code>: the JavaScript file implementing the evaluators, the primitive data types, the primitive functions, etc., constituting the &ldquo;core&rdquo; of the EVLambda programming language</li>
      <li><code>/system/evl2html.xslt</code>: the XSLT file used to convert the EVLambda source files to HTML</li>
      <li><code>/system/evl2html.css</code>: the CSS file styling the EVLambda source files converted to HTML</li>
      <li><code>/system/evl2html.js</code>: the JavaScript file loaded by the EVLambda source files converted to HTML</li>
      <li><code>/system/mantle.evl</code>: the EVLambda source file implementing the nonprimitive data types, the nonprimitive functions, and the macros constituting the &ldquo;mantle&rdquo; of the EVLambda programming language</li>
      <li><code>Listener 1</code>: the initial listener</li>
    </ul>
    <h3>Help Menu</h3>
    <p>The help menu allows you to quickly navigate to various parts of the EVLambda website.</p>
    <p>The help menu contains the following entries:</p>
    <ul>
      <li>Home: link to the home page</li>
      <li>Changelog: link to the changelog</li>
      <li>Contact: link to the contact page</li>
      <li>My Account: link to the login page (if not logged in) or to the account page (if logged in)</li>
      <li>Git Repository: link to the web interface of the official Git repository</li>
      <li>Discussions: link to the discussion forum</li>
      <li>Issues: link to the issue tracker</li>
      <li>Cookie Policy: link to the cookie policy</li>
      <li>Privacy Policy: link to the privacy policy</li>
      <li>Terms of Service: link to the terms of service</li>
      <li>Credits: link to the credits page</li>
      <li>Bill of Materials: link to a list of the libraries used by the IDE</li>
    </ul>
    <h2>Info Bar</h2>
    <p>The info bar displays the type of the current evaluator.</p>
    <h2>Keyboard Shortcuts</h2>
    <table class="ks">
      <tr><th>Linux</th><th>Windows</th><th>macOS</th><th>Command</th></tr>
      <tr><td>ArrowLeft</td><td>ArrowLeft</td><td>ArrowLeft</td><td>cursorCharLeft</td></tr>
      <tr><td>Shift-ArrowLeft</td><td>Shift-ArrowLeft</td><td>Shift-ArrowLeft</td><td>selectCharLeft</td></tr>
      <tr><td>Ctrl-ArrowLeft</td><td>Ctrl-ArrowLeft</td><td>Alt-ArrowLeft</td><td>cursorGroupLeft</td></tr>
      <tr><td>Ctrl-Shift-ArrowLeft</td><td>Ctrl-Shift-ArrowLeft</td><td>Alt-Shift-ArrowLeft</td><td>selectGroupLeft</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-ArrowLeft</td><td>cursorLineBoundaryLeft</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-Shift-ArrowLeft</td><td>selectLineBoundaryLeft</td></tr>
      <tr><td>ArrowRight</td><td>ArrowRight</td><td>ArrowRight</td><td>cursorCharRight</td></tr>
      <tr><td>Shift-ArrowRight</td><td>Shift-ArrowRight</td><td>Shift-ArrowRight</td><td>selectCharRight</td></tr>
      <tr><td>Ctrl-ArrowRight</td><td>Ctrl-ArrowRight</td><td>Alt-ArrowRight</td><td>cursorGroupRight</td></tr>
      <tr><td>Ctrl-Shift-ArrowRight</td><td>Ctrl-Shift-ArrowRight</td><td>Alt-Shift-ArrowRight</td><td>selectGroupRight</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-ArrowRight</td><td>cursorLineBoundaryRight</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-Shift-ArrowRight</td><td>selectLineBoundaryRight</td></tr>
      <tr><td>ArrowUp</td><td>ArrowUp</td><td>ArrowUp</td><td>cursorLineUp</td></tr>
      <tr><td>Shift-ArrowUp</td><td>Shift-ArrowUp</td><td>Shift-ArrowUp</td><td>selectLineUp</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-ArrowUp</td><td>cursorDocStart</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-Shift-ArrowUp</td><td>selectDocStart</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-ArrowUp</td><td>cursorPageUp</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-ArrowUp</td><td>selectPageUp</td></tr>
      <tr><td>ArrowDown</td><td>ArrowDown</td><td>ArrowDown</td><td>cursorLineDown</td></tr>
      <tr><td>Shift-ArrowDown</td><td>Shift-ArrowDown</td><td>Shift-ArrowDown</td><td>selectLineDown</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-ArrowDown</td><td>cursorDocEnd</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-Shift-ArrowDown</td><td>selectDocEnd</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-ArrowDown</td><td>cursorPageDown</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-ArrowDown</td><td>selectPageDown</td></tr>
      <tr><td>PageUp</td><td>PageUp</td><td>PageUp</td><td>cursorPageUp</td></tr>
      <tr><td>Shift-PageUp</td><td>Shift-PageUp</td><td>Shift-PageUp</td><td>selectPageUp</td></tr>
      <tr><td>PageDown</td><td>PageDown</td><td>PageDown</td><td>cursorPageDown</td></tr>
      <tr><td>Shift-PageDown</td><td>Shift-PageDown</td><td>Shift-PageDown</td><td>selectPageDown</td></tr>
      <tr><td>Home</td><td>Home</td><td>Home</td><td>cursorLineBoundaryBackward</td></tr>
      <tr><td>Shift-Home</td><td>Shift-Home</td><td>Shift-Home</td><td>selectLineBoundaryBackward</td></tr>
      <tr><td>Ctrl-Home</td><td>Ctrl-Home</td><td>Cmd-Home</td><td>cursorDocStart</td></tr>
      <tr><td>Ctrl-Shift-Home</td><td>Ctrl-Shift-Home</td><td>Cmd-Shift-Home</td><td>selectDocStart</td></tr>
      <tr><td>End</td><td>End</td><td>End</td><td>cursorLineBoundaryForward</td></tr>
      <tr><td>Shift-End</td><td>Shift-End</td><td>Shift-End</td><td>selectLineBoundaryForward</td></tr>
      <tr><td>Ctrl-End</td><td>Ctrl-End</td><td>Cmd-End</td><td>cursorDocEnd</td></tr>
      <tr><td>Ctrl-Shift-End</td><td>Ctrl-Shift-End</td><td>Cmd-Shift-End</td><td>selectDocEnd</td></tr>
      <tr><td>Enter</td><td>Enter</td><td>Enter</td><td>insertNewlineAndIndent</td></tr>
      <tr><td>Ctrl-a</td><td>Ctrl-a</td><td>Cmd-a</td><td>selectAll</td></tr>
      <tr><td>Backspace</td><td>Backspace</td><td>Backspace</td><td>deleteCharBackward</td></tr>
      <tr><td>Shift-Backspace</td><td>Shift-Backspace</td><td>Shift-Backspace</td><td>deleteCharBackward</td></tr>
      <tr><td>Delete</td><td>Delete</td><td>Delete</td><td>deleteCharForward</td></tr>
      <tr><td>Ctrl-Backspace</td><td>Ctrl-Backspace</td><td>Alt-Backspace</td><td>deleteGroupBackward</td></tr>
      <tr><td>Ctrl-Delete</td><td>Ctrl-Delete</td><td>Alt-Delete</td><td>deleteGroupForward</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-Backspace</td><td>deleteLineBoundaryBackward</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Cmd-Delete</td><td>deleteLineBoundaryForward</td></tr>
      <tr><td>Alt-ArrowLeft</td><td>Alt-ArrowLeft</td><td>Ctrl-ArrowLeft</td><td>cursorSyntaxLeft</td></tr>
      <tr><td>Alt-Shift-ArrowLeft</td><td>Alt-Shift-ArrowLeft</td><td>Ctrl-Shift-ArrowLeft</td><td>selectSyntaxLeft</td></tr>
      <tr><td>Alt-ArrowRight</td><td>Alt-ArrowRight</td><td>Ctrl-ArrowRight</td><td>cursorSyntaxRight</td></tr>
      <tr><td>Alt-Shift-ArrowRight</td><td>Alt-Shift-ArrowRight</td><td>Ctrl-Shift-ArrowRight</td><td>selectSyntaxRight</td></tr>
      <tr><td>Alt-ArrowUp</td><td>Alt-ArrowUp</td><td>Alt-ArrowUp</td><td>moveLineUp</td></tr>
      <tr><td>Alt-Shift-ArrowUp</td><td>Alt-Shift-ArrowUp</td><td>Alt-Shift-ArrowUp</td><td>copyLineUp</td></tr>
      <tr><td>Alt-ArrowDown</td><td>Alt-ArrowDown</td><td>Alt-ArrowDown</td><td>moveLineDown</td></tr>
      <tr><td>Alt-Shift-ArrowDown</td><td>Alt-Shift-ArrowDown</td><td>Alt-Shift-ArrowDown</td><td>copyLineDown</td></tr>
      <tr><td>Escape</td><td>Escape</td><td>Escape</td><td>simplifySelection</td></tr>
      <tr><td>Ctrl-Enter</td><td>Ctrl-Enter</td><td>Cmd-Enter</td><td>insertBlankLine</td></tr>
      <tr><td>Alt-l</td><td>Alt-l</td><td>Ctrl-l</td><td>selectLine</td></tr>
      <tr><td>Ctrl-i</td><td>Ctrl-i</td><td>Cmd-i</td><td>selectParentSyntax</td></tr>
      <tr><td>Ctrl-[</td><td>Ctrl-[</td><td>Cmd-[</td><td>indentLess</td></tr>
      <tr><td>Ctrl-]</td><td>Ctrl-]</td><td>Cmd-]</td><td>indentMore</td></tr>
      <tr><td>Ctrl-Alt-\</td><td>Ctrl-Alt-\</td><td>Cmd-Alt-\</td><td>indentSelection</td></tr>
      <tr><td>Ctrl-Shift-k</td><td>Ctrl-Shift-k</td><td>Cmd-Shift-k</td><td>deleteLine</td></tr>
      <tr><td>Ctrl-Shift-\</td><td>Ctrl-Shift-\</td><td>Cmd-Shift-\</td><td>cursorMatchingBracket</td></tr>
      <tr><td>Ctrl-/</td><td>Ctrl-/</td><td>Cmd-/</td><td>toggleComment</td></tr>
      <tr><td>Alt-Shift-a</td><td>Alt-Shift-a</td><td>Alt-Shift-a</td><td>toggleBlockComment</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-b</td><td>cursorCharLeft</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-b</td><td>selectCharLeft</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-f</td><td>cursorCharRight</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-f</td><td>selectCharRight</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-p</td><td>cursorLineUp</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-p</td><td>selectLineUp</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-n</td><td>cursorLineDown</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-n</td><td>selectLineDown</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-a</td><td>cursorLineStart</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-a</td><td>selectLineStart</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-e</td><td>cursorLineEnd</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Shift-e</td><td>selectLineEnd</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-d</td><td>deleteCharForward</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-h</td><td>deleteCharBackward</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-k</td><td>deleteToLineEnd</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-Alt-h</td><td>deleteGroupBackward</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-o</td><td>splitLine</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-t</td><td>transposeChars</td></tr>
      <tr><td>N/A</td><td>N/A</td><td>Ctrl-v</td><td>cursorPageDown</td></tr>
      <tr><td>Ctrl-z</td><td>Ctrl-z</td><td>Cmd-z</td><td>undo</td></tr>
      <tr><td>Ctrl-y</td><td>Ctrl-y</td><td>Cmd-Shift-z</td><td>redo</td></tr>
      <tr><td>Ctrl-Shift-z</td><td>N/A</td><td>N/A</td><td>redo</td></tr>
      <tr><td>Tab</td><td>Tab</td><td>Tab</td><td>indentSelection</td></tr>
      <tr><td>Ctrl-f</td><td>Ctrl-f</td><td>Cmd-f</td><td>openSearchPanel</td></tr>
      <tr><td>F3</td><td>F3</td><td>F3</td><td>findNext</td></tr>
      <tr><td>Shift-F3</td><td>Shift-F3</td><td>Shift-F3</td><td>findPrevious</td></tr>
      <tr><td>Ctrl-g</td><td>Ctrl-g</td><td>Cmd-g</td><td>findNext</td></tr>
      <tr><td>Ctrl-Shift-g</td><td>Ctrl-Shift-g</td><td>Cmd-Shift-g</td><td>findPrevious</td></tr>
      <tr><td>Escape</td><td>Escape</td><td>Escape</td><td>closeSearchPanel</td></tr>
      <tr><td>Ctrl-Shift-l</td><td>Ctrl-Shift-l</td><td>Cmd-Shift-l</td><td>selectSelectionMatches</td></tr>
      <tr><td>Alt-g</td><td>Alt-g</td><td>Alt-g</td><td>gotoLine</td></tr>
      <tr><td>Ctrl-d</td><td>Ctrl-d</td><td>Cmd-d</td><td>selectNextOccurrence</td></tr>
      <tr><td>Ctrl-s</td><td>Ctrl-s</td><td>Cmd-s</td><td>Save Buffer</td></tr>
      <tr><td>Ctrl-Alt-h</td><td>Ctrl-Alt-h</td><td>Ctrl-Cmd-h</td><td>Toggle HTML Mode</td></tr>
      <tr><td>Ctrl-Alt-e</td><td>Ctrl-Alt-e</td><td>Ctrl-Cmd-e</td><td>Evaluate Form</td></tr>
      <tr><td>Ctrl-Alt-l</td><td>Ctrl-Alt-l</td><td>Ctrl-Cmd-l</td><td>Load Buffer</td></tr>
      <tr><td>Ctrl-Alt-o</td><td>Ctrl-Alt-o</td><td>Ctrl-Cmd-o</td><td>Select Other Window</td></tr>
      <tr><td>Ctrl-Alt-m</td><td>Ctrl-Alt-m</td><td>Ctrl-Cmd-m</td><td>Toggle Maximized State</td></tr>
    </table>
  </body>
</html>
